---
phase: 07-multi-component-target-function
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/core/scoring/__init__.py
  - backend/app/core/scoring/protocol.py
  - backend/app/core/scoring/wiener.py
  - backend/app/core/scoring/molecular_weight.py
  - backend/app/core/scoring/registry.py
  - backend/tests/test_scoring_components.py
autonomous: true

must_haves:
  truths:
    - "WienerIndexComponent.compute() returns the same values as the standalone compute_wiener_index() function for all test molecules"
    - "MolecularWeightComponent.compute() returns correct molecular weight via RDKit Descriptors.MolWt"
    - "ComponentRegistry registers, retrieves, and lists scoring components by name"
    - "Registry rejects duplicate component names with ValueError"
    - "Registry raises KeyError for unknown component names with helpful error message listing available components"
  artifacts:
    - path: "backend/app/core/scoring/protocol.py"
      provides: "ScoringComponent Protocol with name: str and compute(mol_graph) -> float"
      contains: "class ScoringComponent"
    - path: "backend/app/core/scoring/wiener.py"
      provides: "WienerIndexComponent class satisfying ScoringComponent protocol"
      contains: "class WienerIndexComponent"
    - path: "backend/app/core/scoring/molecular_weight.py"
      provides: "MolecularWeightComponent class satisfying ScoringComponent protocol"
      contains: "class MolecularWeightComponent"
    - path: "backend/app/core/scoring/registry.py"
      provides: "ComponentRegistry with register/get/list_components + get_registry() singleton"
      contains: "class ComponentRegistry"
    - path: "backend/tests/test_scoring_components.py"
      provides: "Tests for all scoring components, protocol compliance, and registry"
  key_links:
    - from: "backend/app/core/scoring/wiener.py"
      to: "backend/app/core/wiener.py"
      via: "Same Wiener Index algorithm refactored into component class"
      pattern: "GetDistanceMatrix"
    - from: "backend/app/core/scoring/registry.py"
      to: "backend/app/core/scoring/wiener.py"
      via: "Registry imports and registers WienerIndexComponent"
      pattern: "WienerIndexComponent"
---

<objective>
Create the scoring component framework: Protocol interface, two concrete components (Wiener Index and Molecular Weight), and a component registry with validation.

Purpose: Foundation for multi-component target function. Must exist before SA engine can be refactored (Plan 02).
Output: `backend/app/core/scoring/` package with protocol, two components, registry, and comprehensive tests.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-component-target-function/07-RESEARCH.md
@backend/app/core/wiener.py
@backend/app/core/molecule.py
@backend/tests/test_wiener.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for scoring components and registry</name>
  <files>
    backend/tests/test_scoring_components.py
    backend/app/core/scoring/__init__.py
  </files>
  <action>
Create `backend/app/core/scoring/__init__.py` as an empty file (needed for imports to resolve).

Create `backend/tests/test_scoring_components.py` with these test classes:

**TestWienerIndexComponent:**
- `test_name_is_wiener_index`: assert `component.name == "wiener_index"`
- `test_linear_hexane_wiener_35`: Create `MoleculeGraph.create_linear_alkane(6)`, assert `component.compute(graph) == 35`
- `test_isobutane_wiener_9`: Create `MoleculeGraph.create_branched('isobutane')`, assert `component.compute(graph) == 9`
- `test_neopentane_wiener_16`: Create `MoleculeGraph.create_branched('neopentane')`, assert `component.compute(graph) == 16`
- `test_cyclohexane_wiener_27`: Create `MoleculeGraph.create_cyclohexane()`, assert `component.compute(graph) == 27`
- `test_matches_standalone_function`: For C6 linear alkane, assert `component.compute(graph) == compute_wiener_index(graph)` (backward compatibility check against existing standalone function in `app.core.wiener`)

**TestMolecularWeightComponent:**
- `test_name_is_molecular_weight`: assert `component.name == "molecular_weight"`
- `test_hexane_mw`: Create `MoleculeGraph.create_linear_alkane(6)`, assert `85.0 < component.compute(graph) < 87.0` (C6H14 = 86.18 Da)
- `test_methane_mw`: Create `MoleculeGraph.create_linear_alkane(1)`, assert `15.0 < component.compute(graph) < 17.0` (CH4 = 16.04 Da)

**TestProtocolCompliance:**
- `test_wiener_has_name_and_compute`: assert `hasattr(WienerIndexComponent(), 'name')` and `callable(getattr(WienerIndexComponent(), 'compute'))`
- `test_molecular_weight_has_name_and_compute`: same for MolecularWeightComponent

**TestComponentRegistry:**
- `test_default_registry_has_wiener`: `get_registry().get("wiener_index")` does not raise
- `test_default_registry_has_molecular_weight`: `get_registry().get("molecular_weight")` does not raise
- `test_list_components`: `get_registry().list_components()` contains both names
- `test_unknown_component_raises_keyerror`: `get_registry().get("nonexistent")` raises `KeyError`
- `test_unknown_component_error_lists_available`: The KeyError message contains "wiener_index" and "molecular_weight"
- `test_duplicate_registration_raises`: Create a new `ComponentRegistry()`, register a component, then register another with the same name -- assert `ValueError`

IMPORTANT: MoleculeGraph does NOT have a `from_smiles()` class method. Use `create_linear_alkane()`, `create_branched()`, and `create_cyclohexane()` factory methods instead.

Import from:
- `from app.core.scoring.wiener import WienerIndexComponent`
- `from app.core.scoring.molecular_weight import MolecularWeightComponent`
- `from app.core.scoring.registry import ComponentRegistry, get_registry`
- `from app.core.wiener import compute_wiener_index` (for backward compat test)
- `from app.core.molecule import MoleculeGraph`

Run `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_components.py -x` -- ALL tests must FAIL (RED phase). Expect ImportErrors since the modules don't exist yet.
  </action>
  <verify>Tests fail with ImportError (modules don't exist yet). Run: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_components.py -x 2>&1 | head -20` and confirm failure.</verify>
  <done>test_scoring_components.py exists with 15+ tests, all failing because scoring modules don't exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement scoring components and registry to pass all tests</name>
  <files>
    backend/app/core/scoring/__init__.py
    backend/app/core/scoring/protocol.py
    backend/app/core/scoring/wiener.py
    backend/app/core/scoring/molecular_weight.py
    backend/app/core/scoring/registry.py
  </files>
  <action>
**1. `backend/app/core/scoring/protocol.py`:**

```python
from typing import Protocol, runtime_checkable
from app.core.molecule import MoleculeGraph

@runtime_checkable
class ScoringComponent(Protocol):
    """Structural interface for scoring components."""
    name: str

    def compute(self, mol_graph: MoleculeGraph) -> float:
        """Compute score for the given molecular graph."""
        ...
```

Use `@runtime_checkable` so isinstance() checks work at runtime (useful for debugging).

**2. `backend/app/core/scoring/wiener.py`:**

Refactor the logic from `backend/app/core/wiener.py` into a class:

```python
from rdkit import Chem
from app.core.molecule import MoleculeGraph

class WienerIndexComponent:
    """Wiener Index scoring component (sum of pairwise distances)."""
    name = "wiener_index"

    def compute(self, mol_graph: MoleculeGraph) -> float:
        mol = mol_graph.get_mol()
        n = mol.GetNumAtoms()
        if n <= 1:
            return 0
        dist_matrix = Chem.GetDistanceMatrix(mol)
        for i in range(n):
            for j in range(n):
                if dist_matrix[i][j] > 1000:
                    raise ValueError('Graph is disconnected')
        return sum(
            dist_matrix[i][j]
            for i in range(n)
            for j in range(i + 1, n)
        )
```

This is the same algorithm as `backend/app/core/wiener.py:compute_wiener_index()`.

**3. `backend/app/core/scoring/molecular_weight.py`:**

```python
from app.core.molecule import MoleculeGraph
from rdkit.Chem import Descriptors

class MolecularWeightComponent:
    """Molecular weight scoring component (sum of atomic masses including implicit H)."""
    name = "molecular_weight"

    def compute(self, mol_graph: MoleculeGraph) -> float:
        mol = mol_graph.get_mol()
        return Descriptors.MolWt(mol)
```

Use RDKit's built-in `Descriptors.MolWt()` -- do NOT hand-roll.

**4. `backend/app/core/scoring/registry.py`:**

```python
from app.core.scoring.protocol import ScoringComponent
from app.core.scoring.wiener import WienerIndexComponent
from app.core.scoring.molecular_weight import MolecularWeightComponent

class ComponentRegistry:
    def __init__(self):
        self._components: dict[str, ScoringComponent] = {}

    def register(self, component: ScoringComponent) -> None:
        if component.name in self._components:
            raise ValueError(f"Component '{component.name}' already registered")
        self._components[component.name] = component

    def get(self, name: str) -> ScoringComponent:
        if name not in self._components:
            available = ', '.join(sorted(self._components.keys()))
            raise KeyError(f"Unknown component '{name}'. Available: {available}")
        return self._components[name]

    def list_components(self) -> list[str]:
        return list(self._components.keys())

_registry = ComponentRegistry()
_registry.register(WienerIndexComponent())
_registry.register(MolecularWeightComponent())

def get_registry() -> ComponentRegistry:
    return _registry
```

**5. `backend/app/core/scoring/__init__.py`:**

Export public API:
```python
from app.core.scoring.protocol import ScoringComponent
from app.core.scoring.registry import ComponentRegistry, get_registry
```

Run tests: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_components.py -v`

ALL tests must PASS (GREEN phase).

Also run existing tests to confirm no regressions: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_wiener.py tests/test_sa_engine.py -v`
  </action>
  <verify>Run: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_components.py tests/test_wiener.py tests/test_sa_engine.py -v` -- all tests pass.</verify>
  <done>All scoring component tests pass. Existing wiener and SA engine tests still pass (no regressions). The `backend/app/core/scoring/` package exports ScoringComponent protocol, two concrete components, and ComponentRegistry.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_scoring_components.py -v` -- all 15+ tests pass
2. `python -m pytest tests/test_wiener.py -v` -- existing Wiener tests still pass (backward compat)
3. `python -m pytest tests/test_sa_engine.py -v` -- existing SA tests still pass (no regressions)
4. `WienerIndexComponent().compute(graph)` returns identical values to `compute_wiener_index(graph)` for all test molecules
5. `ComponentRegistry` validates names and raises clear errors
</verification>

<success_criteria>
- `backend/app/core/scoring/` package exists with protocol.py, wiener.py, molecular_weight.py, registry.py
- ScoringComponent Protocol defines `name: str` and `compute(mol_graph) -> float`
- WienerIndexComponent computes identical results to standalone `compute_wiener_index()`
- MolecularWeightComponent uses `RDKit Descriptors.MolWt()`
- ComponentRegistry supports register/get/list_components with validation
- All 15+ new tests pass, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-component-target-function/07-01-SUMMARY.md`
</output>
