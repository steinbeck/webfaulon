---
phase: 01-molecular-graph-sa-core
plan: 04
type: tdd
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/core/cooling.ts
  - src/core/SAEngine.ts
  - src/core/__tests__/cooling.test.ts
  - src/core/__tests__/SAEngine.test.ts
autonomous: true

must_haves:
  truths:
    - "SA minimization on C6H14 finds Wiener Index lower than initial linear chain value"
    - "SA maximization on C6H14 finds Wiener Index equal to or higher than initial value"
    - "SA with same seed produces identical results (same best energy, same step count)"
    - "Metropolis criterion always accepts improving moves (delta_e < 0)"
    - "Metropolis criterion probabilistically accepts worsening moves at high temperature"
    - "Metropolis criterion almost never accepts worsening moves at near-zero temperature"
    - "Cooling schedule f0 (linear) reaches near-zero temperature at final step"
    - "SA reports step-by-step results (step number, energy, temperature, accepted)"
  artifacts:
    - path: "src/core/cooling.ts"
      provides: "Cooling schedule implementations from Faulon paper Tables 3-4"
      exports: ["computeTemperature", "CoolingScheduleType"]
      min_lines: 40
    - path: "src/core/SAEngine.ts"
      provides: "Full SA engine with Metropolis acceptance and step reporting"
      exports: ["SAEngine", "SAParams", "SAResult"]
      min_lines: 120
    - path: "src/core/__tests__/cooling.test.ts"
      provides: "Cooling schedule tests"
      contains: "describe.*cooling"
    - path: "src/core/__tests__/SAEngine.test.ts"
      provides: "SA engine integration tests"
      contains: "describe.*SAEngine"
  key_links:
    - from: "src/core/SAEngine.ts"
      to: "src/core/displacement.ts"
      via: "calls attemptDisplacement for each SA iteration"
      pattern: "import.*attemptDisplacement"
    - from: "src/core/SAEngine.ts"
      to: "src/core/wiener.ts"
      via: "calls computeWienerIndex as cost function"
      pattern: "import.*computeWienerIndex"
    - from: "src/core/SAEngine.ts"
      to: "src/core/cooling.ts"
      via: "calls computeTemperature to update kT each step"
      pattern: "import.*computeTemperature"
    - from: "src/core/SAEngine.ts"
      to: "src/core/initialStructure.ts"
      via: "uses generateInitialStructure to create starting graph from formula"
      pattern: "import.*generateInitialStructure"
    - from: "src/core/SAEngine.ts"
      to: "src/core/random.ts"
      via: "passes SeededRandom instance to displacement function"
      pattern: "import.*SeededRandom"
---

<objective>
Implement the SA engine with Metropolis acceptance criterion, configurable cooling schedules, and max/min optimization toggle using TDD. This plan integrates all prior components (MolGraph, Wiener Index, displacement, initial structure) into the complete simulated annealing algorithm from Faulon's paper.

Purpose: ALG-04 (max/min toggle) and ALG-05 (Metropolis criterion) are the final algorithmic requirements. This plan wires everything together: the SA engine takes a molecular formula, generates an initial structure, then iteratively applies displacements with Metropolis acceptance to optimize the Wiener Index. The cooling schedules follow Tables 3-4 from the paper.
Output: Complete, tested SA engine that can optimize Wiener Index for any valid molecular formula, with reproducible results via seeded PRNG.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-molecular-graph-sa-core/01-RESEARCH.md
@.planning/phases/01-molecular-graph-sa-core/01-01-SUMMARY.md
@.planning/phases/01-molecular-graph-sa-core/01-02-SUMMARY.md
@.planning/phases/01-molecular-graph-sa-core/01-03-SUMMARY.md
</context>

<feature>
  <name>SA Engine with Metropolis Criterion and Cooling Schedules</name>
  <files>
    src/core/cooling.ts, src/core/__tests__/cooling.test.ts,
    src/core/SAEngine.ts, src/core/__tests__/SAEngine.test.ts
  </files>
  <behavior>
**Cooling Schedules (src/core/cooling.ts):**

Implement the cooling schedule family from Faulon paper Tables 3-4.

The paper uses: kT_t = kT_0 - k * kT_0 * t / delta_t (clamped to minimum of 0.01 to avoid division by zero in Metropolis). The parameter k controls cooling rate:
- k=0 (f0): constant temperature (kT stays at kT_0)
- k=1 (f1): linear cooling to 0
- k=8 (f8): fast decay (paper's best schedule)
- k=32 (f32): very fast decay

Function:
```typescript
export type CoolingScheduleType = number; // k parameter (0, 1, 2, ..., 32)

export function computeTemperature(
  step: number,
  totalSteps: number,
  initialTemp: number,
  scheduleK: CoolingScheduleType
): number
```

Formula: T = max(0.01, T0 - k * T0 * step / totalSteps)

Cases:
- k=0, any step: T = T0 (constant)
- k=1, step=0: T = T0 (start)
- k=1, step=totalSteps: T = 0.01 (clamped min)
- k=1, step=totalSteps/2: T = T0/2
- k=8, step=totalSteps/8: T = 0.01 (reaches min early)
- k=8, step=0: T = T0

**SA Engine (src/core/SAEngine.ts):**

```typescript
export interface SAParams {
  formula: string;           // Molecular formula (e.g., "C6H14")
  initialTemp: number;       // kT_0 (default: 100, per paper)
  coolingScheduleK: number;  // k parameter for cooling (default: 8)
  stepsPerCycle: number;     // Steps per temperature cycle (default: 500)
  numCycles: number;         // Number of cooling cycles (default: 4)
  optimizationMode: OptimizationMode; // 'MAXIMIZE' or 'MINIMIZE'
  seed: number;              // Random seed for reproducibility
}

export interface SAResult {
  bestGraph: MolGraph;
  bestEnergy: number;
  finalGraph: MolGraph;
  finalEnergy: number;
  initialEnergy: number;
  totalSteps: number;
  acceptedMoves: number;
  rejectedMoves: number;
  invalidMoves: number;      // Moves rejected due to connectivity/valence
  acceptanceRatio: number;
  history: SAStepResult[];   // Step-by-step results for charting (Phase 3)
}
```

SA Engine algorithm (Faulon paper Table 2):
1. Parse formula and generate initial structure
2. Compute initial Wiener Index
3. For each cycle (1 to numCycles):
   a. Reset temperature to initialTemp
   b. For each step (1 to stepsPerCycle):
      - Attempt displacement on current graph
      - If displacement returns null: increment invalidMoves, continue
      - Compute Wiener Index of proposed graph
      - Compute delta_e based on optimizationMode:
        - MINIMIZE: delta_e = proposed - current (positive = worse)
        - MAXIMIZE: delta_e = current - proposed (positive = worse)
      - Metropolis acceptance (ALG-05):
        - If delta_e <= 0: ACCEPT (improving move)
        - Else: accept with probability exp(-delta_e / temperature)
        - Use rng.next() < probability for the random check
      - If accepted: update current graph and energy
      - If current energy is new best: update best graph and energy
      - Record SAStepResult in history array
      - Update temperature via cooling schedule
4. Return SAResult

The history array records every step for the live chart in Phase 3. Each entry has: step number, current energy, best energy so far, temperature, and whether the move was accepted.

Cases (SA Engine):
- Minimize C6H14 (500 steps, k=8, seed=42): bestEnergy < initialEnergy
- Maximize C6H14 (500 steps, k=8, seed=42): bestEnergy >= initialEnergy
- Same params + same seed: identical SAResult (same bestEnergy, same acceptedMoves)
- Different seeds: different results (with high probability)
- history array has length = stepsPerCycle * numCycles
- acceptedMoves + rejectedMoves + invalidMoves = totalSteps
- bestGraph.isConnected() == true and bestGraph.hasValidValences() == true
- finalGraph.isConnected() == true and finalGraph.hasValidValences() == true

Metropolis criterion unit tests (isolated):
- delta_e = -5, any T: always accept
- delta_e = 0, any T: always accept
- delta_e = 100, T = 0.01: almost never accept (probability ~ 0)
- delta_e = 1, T = 1000: almost always accept (probability ~ 1)
- delta_e = 10, T = 10: accept ~37% of time (exp(-1) ~ 0.368)
  </behavior>
  <implementation>
**RED phase:** Write tests for cooling schedules and SA engine.

Cooling tests: Verify temperature values for k=0 (constant), k=1 (linear), k=8 (fast decay) at various step fractions (0%, 25%, 50%, 100%). Verify clamping to 0.01 minimum.

SA Engine tests:
1. Determinism test: Run SA twice with same params + seed, assert identical bestEnergy
2. Minimization test: Run SA on C6H14, assert bestEnergy < initialEnergy (linear hexane Wiener=35, any branching reduces it)
3. Maximization test: Run SA on C6H14, assert bestEnergy >= initialEnergy
4. Validity test: Assert bestGraph and finalGraph pass isConnected() and hasValidValences()
5. History test: Assert history length equals totalSteps, each entry has valid fields
6. Accounting test: Assert acceptedMoves + rejectedMoves + invalidMoves == totalSteps

Metropolis tests (can be tested as a standalone function):
1. Improving move (delta <= 0): always returns true
2. Very bad move at low temp: returns false (test with 1000 trials, acceptance < 5%)
3. Mild bad move at high temp: returns true often (test with 1000 trials, acceptance > 30%)

**GREEN phase:** Implement cooling.ts first (simple math), then SAEngine.ts.

For SAEngine: Create the engine as a class with:
- constructor(params: SAParams) -- sets up initial state
- run(): SAResult -- runs full SA to completion
- Private: iterate() for single step, metropolisAccept(deltaE, temperature) for acceptance

**REFACTOR phase:** Extract Metropolis acceptance into a pure function (testable independently). Clean up history recording. Ensure SAResult types are clean for Phase 3 consumption.

**Integration verification (in test):** Run SA on C6H14 with paper's recommended params (kT_0=100, k=8, 500 steps/cycle, 4 cycles). Log initial and best Wiener Index. Verify the algorithm actually optimizes (best != initial for nontrivial molecules).
  </implementation>
</feature>

<verification>
1. `npm test -- --run src/core/__tests__/cooling.test.ts` -- all cooling schedule tests pass
2. `npm test -- --run src/core/__tests__/SAEngine.test.ts` -- all SA engine tests pass
3. `npm test -- --run` -- FULL suite passes (all plans 01-04, 60+ tests total)
4. `npx tsc --noEmit` -- zero TypeScript errors
5. SA on C6H14 with minimization finds Wiener < 35 (linear chain value)
6. SA on C6H14 with maximization finds Wiener >= 35
7. Identical seeds produce identical results
8. All output graphs are chemically valid (connected, valid valences)
</verification>

<success_criteria>
- Cooling schedules match paper formula for k=0, 1, 8, 32
- Metropolis acceptance correct: always accept improvements, probabilistic for worsening moves
- SA minimization demonstrably reduces Wiener Index from initial value
- SA maximization demonstrably increases (or maintains) Wiener Index from initial value
- Full reproducibility with same seed
- Step-by-step history recorded for future charting
- All graphs produced by SA are chemically valid
- 20+ tests passing across both test files, 60+ total in full suite
- Phase 1 complete: all 6 requirements (ALG-01 through ALG-06) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-molecular-graph-sa-core/01-04-SUMMARY.md`
</output>
