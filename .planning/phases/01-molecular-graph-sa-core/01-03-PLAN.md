---
phase: 01-molecular-graph-sa-core
plan: 03
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/displacement.ts
  - src/core/random.ts
  - src/core/__tests__/displacement.test.ts
  - src/core/__tests__/random.test.ts
autonomous: true

must_haves:
  truths:
    - "Displacement on a valid molecule produces a valid molecule (or null for rejected move)"
    - "All computed bond orders are in range [0, 3] after displacement"
    - "Displaced molecule has same atom count and types as original"
    - "Displaced molecule passes connectivity check (or move is rejected)"
    - "Displaced molecule passes valence validation (or move is rejected)"
    - "Seeded PRNG produces identical sequences for identical seeds"
    - "Displacement with seeded PRNG is fully reproducible"
  artifacts:
    - path: "src/core/displacement.ts"
      provides: "Faulon displacement equations 7-11 implementation"
      exports: ["attemptDisplacement"]
      min_lines: 80
    - path: "src/core/random.ts"
      provides: "Seeded PRNG for reproducible SA runs"
      exports: ["SeededRandom"]
      min_lines: 30
    - path: "src/core/__tests__/displacement.test.ts"
      provides: "Comprehensive displacement tests (50+ cases)"
      contains: "describe.*displacement"
    - path: "src/core/__tests__/random.test.ts"
      provides: "Seeded PRNG tests"
      contains: "describe.*SeededRandom"
  key_links:
    - from: "src/core/displacement.ts"
      to: "src/core/MolGraph.ts"
      via: "imports MolGraph, calls clone/setBond/isConnected/hasValidValences"
      pattern: "import.*MolGraph"
    - from: "src/core/displacement.ts"
      to: "src/core/random.ts"
      via: "uses SeededRandom for atom selection and b11 choice"
      pattern: "import.*SeededRandom"
---

<objective>
Implement Faulon's displacement operation (equations 7-11 from the 1996 paper) and a seeded PRNG using TDD. This is the core SA mutation: pick 4 atoms, redistribute bond orders while preserving valences and connectivity.

Purpose: ALG-01 requires implementing equations 7-11 for bond order redistribution. This is the most mathematically critical piece -- incorrect implementation produces chemically invalid molecules. TDD ensures every equation is verified before integration. The seeded PRNG (research recommendation) ensures reproducibility: same seed produces identical SA runs.
Output: Displacement function with exhaustive validation, seeded PRNG, comprehensive test suite with 50+ test cases.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-molecular-graph-sa-core/01-RESEARCH.md
@.planning/phases/01-molecular-graph-sa-core/01-01-SUMMARY.md
</context>

<feature>
  <name>Faulon Displacement (Equations 7-11) and Seeded PRNG</name>
  <files>
    src/core/random.ts, src/core/__tests__/random.test.ts,
    src/core/displacement.ts, src/core/__tests__/displacement.test.ts
  </files>
  <behavior>
**Seeded PRNG (src/core/random.ts):**

Implement a seedable pseudo-random number generator. Do NOT use Math.random() -- it is not seedable and breaks reproducibility (Faulon paper p.733: "Two runs using the same seed will lead to the same results").

Use a simple Mulberry32 or xoshiro128** algorithm (fast, good distribution, small code). No external dependency needed.

Class: SeededRandom
- constructor(seed: number) -- initialize PRNG state from seed
- next(): number -- returns float in [0, 1)
- nextInt(min: number, max: number): number -- returns integer in [min, max] inclusive
- selectNDistinct(n: number, range: number): number[] -- select n distinct random integers from [0, range)

Cases:
- SeededRandom(42).next() always returns same value
- Two instances with seed 42 produce identical sequences of 1000 values
- Two instances with different seeds produce different sequences
- nextInt(0, 5) always returns value in [0, 5]
- selectNDistinct(4, 10) returns 4 distinct values in [0, 10)

**Faulon Displacement (src/core/displacement.ts):**

Function signature:
```typescript
export function attemptDisplacement(
  graph: MolGraph,
  rng: SeededRandom
): MolGraph | null
```

Returns a NEW MolGraph with bonds redistributed, or null if the move is invalid.

Algorithm (Faulon 1996, equations 7-11, Table 2):
1. Select 4 distinct atom indices using rng.selectNDistinct(4, atomCount)
   - Label them x1, y1, x2, y2
2. Read current bond orders (a notation from paper):
   - a11 = bonds[x1][y1]  (bond between x1 and y1)
   - a12 = bonds[y1][y2]  (bond between y1 and y2)
   - a21 = bonds[x1][x2]  (bond between x1 and x2)
   - a22 = bonds[x2][y2]  (bond between x2 and y2)
3. Compute valid range for b11 (new bond order for x1-y1):
   - Equation 10: b11_min = max(0, a11-a22, a11-a21, a11+a12-3, a11+a21-3) -- NOTE: corrected from research which had a duplicate. Paper eq 10 has: max(0, a11+a12-3, a11+a21-3, a11-a22, a11-a12) -- COPY EXACTLY FROM PAPER EQUATIONS.
   - Equation 11: b11_max = min(3, a11+a12, a11+a21, a11-a22+3)
   - CRITICAL: Read equations 10-11 DIRECTLY from the paper (docs/ folder) before implementing. The research file may have transcription errors. The paper is the ground truth.
4. If b11_min > b11_max: return null (no valid move for this atom selection)
5. Choose b11 randomly from [b11_min, b11_max] using rng.nextInt
   - IMPORTANT: If b11 == a11 (no change), this is a null move. Still valid but wastes a step.
6. Compute remaining new bond orders (equations 7-9):
   - b12 = a11 + a12 - b11  (eq 7)
   - b21 = a11 + a21 - b11  (eq 8)
   - b22 = a22 - a11 + b11  (eq 9)
7. Assert all bond orders in [0, 3] (should be guaranteed by constraints, but verify)
8. Clone the graph
9. Apply new bond orders: setBond(x1,y1,b11), setBond(y1,y2,b12), setBond(x1,x2,b21), setBond(x2,y2,b22)
10. Check connectivity: if !newGraph.isConnected(), return null
11. Check valences: if !newGraph.hasValidValences(), return null
12. Return newGraph

Cases (displacement):
- Linear hexane: attempt displacement, result is either valid molecule or null
- Any displacement result has same atom count as input
- Bond orders in result are all in [0, 3]
- Result (if not null) passes isConnected() and hasValidValences()
- Running 100 displacements on hexane with same seed gives identical results
- Running 100 displacements on hexane: some succeed (not null), none produce invalid molecules
- Bridge bond scenario: molecule where removing the only bond between two halves returns null
- Already-maximal bonds: C=C=C (allene-like) displacement near triple bonds respects max bond order 3
- Molecules with < 4 atoms: return null always
  </behavior>
  <implementation>
**RED phase:** Write tests for both SeededRandom and displacement.

For random tests: test determinism (same seed = same sequence), distribution (nextInt stays in range over 10000 calls), selectNDistinct produces correct count with no duplicates.

For displacement tests: test with linear hexane (100 iterations, verify all results valid or null), test with cyclohexane, test reproducibility with same seed, test molecules with < 4 atoms return null, test that atom count never changes, test bond order bounds.

The key test: Run 500 random displacements on a hexane molecule. For every non-null result, assert isConnected() and hasValidValences(). This is the "100+ displacement tests" the research recommends.

**GREEN phase:** Implement SeededRandom first (displacement depends on it), then displacement.

For SeededRandom: Implement Mulberry32 algorithm:
```
function mulberry32(a: number) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    var t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
```

For displacement: Follow the algorithm above step by step. Copy equations 7-11 as comments directly from the paper. Include assertion after step 7 to catch math errors during development.

**REFACTOR phase:** Extract equation computation into a named helper (computeDisplacementBonds) for readability. Ensure all magic numbers are documented with paper references.
  </implementation>
</feature>

<verification>
1. `npm test -- --run src/core/__tests__/random.test.ts` -- all PRNG tests pass
2. `npm test -- --run src/core/__tests__/displacement.test.ts` -- all displacement tests pass (50+ cases)
3. `npm test -- --run` -- full suite passes (no regressions from Plan 01)
4. `npx tsc --noEmit` -- zero TypeScript errors
5. 500 random displacements on hexane: 0 invalid molecules produced
6. Same seed produces identical displacement sequences
</verification>

<success_criteria>
- SeededRandom is deterministic: same seed always produces same sequence
- Displacement correctly implements equations 7-11 from Faulon paper
- All displacement results (non-null) pass connectivity and valence checks
- Molecules with < 4 atoms return null
- 500-iteration stress test produces zero invalid molecules
- Displacement + PRNG are fully reproducible with same seed
- 30+ tests passing across both test files
</success_criteria>

<output>
After completion, create `.planning/phases/01-molecular-graph-sa-core/01-03-SUMMARY.md`
</output>
