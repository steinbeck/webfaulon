---
phase: 02-browser-integration-controls
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - package.json
  - vite.config.ts
  - index.html
  - src/main.ts
  - src/worker/sa-worker.ts
  - src/worker/types.ts
autonomous: true

must_haves:
  truths:
    - "Web Worker runs SAEngine without blocking main thread"
    - "Comlink proxy enables typed async calls from main thread to worker"
    - "Progress callbacks report step data back to main thread during execution"
    - "Worker can be paused, resumed, and terminated cleanly"
    - "Vite dev server bundles worker with TypeScript support"
  artifacts:
    - path: "src/worker/sa-worker.ts"
      provides: "Comlink-exposed SAEngine wrapper with progress reporting"
      contains: "Comlink.expose"
    - path: "src/worker/types.ts"
      provides: "Worker API interface and message types"
      contains: "ISAWorker"
    - path: "vite.config.ts"
      provides: "Vite configuration with worker support"
      contains: "defineConfig"
    - path: "index.html"
      provides: "HTML entry point for Vite SPA"
      contains: "src/main.ts"
    - path: "src/main.ts"
      provides: "Application entry point with worker initialization"
      contains: "new Worker"
  key_links:
    - from: "src/main.ts"
      to: "src/worker/sa-worker.ts"
      via: "new Worker(new URL()) + Comlink.wrap()"
      pattern: "new Worker.*sa-worker"
    - from: "src/worker/sa-worker.ts"
      to: "src/core/SAEngine.ts"
      via: "import and instantiate SAEngine"
      pattern: "import.*SAEngine"
    - from: "src/worker/sa-worker.ts"
      to: "src/main.ts"
      via: "Comlink.proxy callback for progress"
      pattern: "onProgress"
---

<objective>
Create the Web Worker infrastructure with Comlink for off-main-thread SA execution.

Purpose: SAEngine runs 10,000+ iterations which would freeze the browser if executed on the main thread. This plan creates the Worker + Comlink layer that lets the UI call SAEngine methods asynchronously and receive progress updates via callbacks, enabling responsive UI during computation.

Output: Working Web Worker with Comlink proxy, Vite project scaffold (index.html, vite.config.ts, main.ts), and typed worker API with pause/resume/progress support.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-browser-integration-controls/02-RESEARCH.md
@.planning/phases/02-browser-integration-controls/02-01-SUMMARY.md
@src/core/SAEngine.ts
@src/core/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Vite project scaffold</name>
  <files>package.json, vite.config.ts, index.html, src/main.ts, tsconfig.json</files>
  <action>
**Install dependencies:**
```bash
npm install comlink alpinejs
npm install -D @types/alpinejs
```

Note: Do NOT install @rdkit/rdkit yet (handled in Plan 03).

**Create vite.config.ts** (separate from vitest.config.ts):
```typescript
import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  worker: {
    format: 'es',
  },
  build: {
    target: 'es2020',
  },
});
```

**Create index.html** in project root:
- Standard HTML5 boilerplate
- `<script type="module" src="/src/main.ts"></script>` in body
- Minimal placeholder content: `<div id="app">Loading...</div>`
- No Alpine.js markup yet (Plan 03 adds UI)

**Create src/main.ts** with basic worker initialization:
```typescript
import * as Comlink from 'comlink';
import type { ISAWorker } from './worker/types';

let worker: Worker | null = null;
let saWorker: Comlink.Remote<ISAWorker> | null = null;

export async function initWorker(): Promise<Comlink.Remote<ISAWorker>> {
  if (saWorker) return saWorker;

  worker = new Worker(
    new URL('./worker/sa-worker.ts', import.meta.url),
    { type: 'module' }
  );
  saWorker = Comlink.wrap<ISAWorker>(worker);
  return saWorker;
}

export function terminateWorker(): void {
  if (worker) {
    worker.terminate();
    worker = null;
    saWorker = null;
  }
}

// Cleanup on page exit
window.addEventListener('beforeunload', terminateWorker);

// Log initialization for verification
console.log('WebFaulon main.ts loaded');
```

**Update tsconfig.json**: Add `"WebWorker"` to the `lib` array so worker global types are available:
```json
"lib": ["ES2020", "DOM", "DOM.Iterable", "WebWorker"]
```

**Verify:** `npx vite build` should succeed (even if the worker file doesn't exist yet, Vite should at least parse main.ts). `npx vitest run` should still pass all existing tests.
  </action>
  <verify>Run `npx vitest run` (all existing tests pass). Run `npx tsc --noEmit` (no errors). Verify vite.config.ts, index.html, src/main.ts exist.</verify>
  <done>Vite project scaffold in place. Dependencies installed. Dev server can start (`npx vite` shows page). All existing tests unaffected.</done>
</task>

<task type="auto">
  <name>Task 2: Create worker API types and ISAWorker interface</name>
  <files>src/worker/types.ts</files>
  <action>
Create `src/worker/types.ts` with explicit interface for the worker API. This is what Comlink.wrap will use for type safety.

```typescript
import type { SAParams, SAResult, SAEngineState } from '../core/types';

/**
 * Progress data sent from worker to main thread during SA execution.
 * Kept small (primitives only) to minimize postMessage overhead.
 */
export interface SAProgressData {
  step: number;
  totalSteps: number;
  cycle: number;
  currentEnergy: number;
  bestEnergy: number;
  temperature: number;
  accepted: boolean;         // Whether the last move was accepted
  acceptedMoves: number;
  rejectedMoves: number;
  invalidMoves: number;
  isComplete: boolean;
}

/**
 * Worker API interface exposed via Comlink.
 * All methods are async from the main thread's perspective.
 */
export interface ISAWorker {
  /**
   * Initialize SA engine with parameters and begin step-by-step execution.
   * Must be called before run().
   */
  initialize(params: SAParams): Promise<void>;

  /**
   * Run SA to completion with progress callbacks.
   * Calls onProgress every `reportInterval` steps.
   * Respects pause/resume signals.
   *
   * @param onProgress - Callback receiving progress data (use Comlink.proxy)
   * @param reportInterval - Report progress every N steps (default: 10)
   */
  run(
    onProgress: (data: SAProgressData) => void,
    reportInterval?: number
  ): Promise<SAResult>;

  /**
   * Pause execution (takes effect after current step completes).
   */
  pause(): void;

  /**
   * Resume paused execution.
   */
  resume(): void;

  /**
   * Check if currently paused.
   */
  isPaused(): boolean;

  /**
   * Reset engine to uninitialized state.
   * Allows reuse of the worker for a new run.
   */
  reset(): void;
}
```

Note: SAParams and SAResult types are imported from core/types.ts. We need to re-export SAParams from core/types.ts or ensure it's accessible. Currently SAParams is defined in SAEngine.ts -- move the interface to types.ts so both core code and worker code can import it without importing the full SAEngine class.

**Also update src/core/types.ts**: Move SAParams and SAResult interfaces from SAEngine.ts to types.ts (better separation, avoids worker importing entire SAEngine module for just types). Update SAEngine.ts to import them from types.ts.

**Also update src/core/SAEngine.ts**: Change from local interface definitions to imports:
```typescript
import type { OptimizationMode, SAStepResult, SAParams, SAResult, SAEngineState } from './types';
```
Remove the SAParams and SAResult interface declarations from SAEngine.ts (they now live in types.ts).
  </action>
  <verify>Run `npx tsc --noEmit` (zero errors). Run `npx vitest run` (all tests pass). Verify src/worker/types.ts exists with ISAWorker interface.</verify>
  <done>Worker API typed. SAParams/SAResult moved to shared types.ts. ISAWorker interface defines the full worker contract.</done>
</task>

<task type="auto">
  <name>Task 3: Implement sa-worker.ts with Comlink exposure</name>
  <files>src/worker/sa-worker.ts</files>
  <action>
Create `src/worker/sa-worker.ts` implementing ISAWorker:

```typescript
import * as Comlink from 'comlink';
import { SAEngine } from '../core/SAEngine';
import type { SAParams, SAResult } from '../core/types';
import type { ISAWorker, SAProgressData } from './types';

class SAWorker implements ISAWorker {
  private engine: SAEngine | null = null;
  private params: SAParams | null = null;
  private _isPaused = false;

  async initialize(params: SAParams): Promise<void> {
    this.params = params;
    this.engine = new SAEngine(params);
    this.engine.init();
    this._isPaused = false;
  }

  async run(
    onProgress: (data: SAProgressData) => void,
    reportInterval = 10
  ): Promise<SAResult> {
    if (!this.engine) {
      throw new Error('Engine not initialized. Call initialize() first.');
    }

    const state = this.engine.getState();
    const totalSteps = state.totalSteps;

    while (!this.engine.getState().isComplete) {
      // Check for pause
      if (this._isPaused) {
        // Yield to event loop, then re-check pause flag
        await new Promise<void>(resolve => setTimeout(resolve, 0));
        continue;
      }

      this.engine.step();

      const currentState = this.engine.getState();

      // Report progress at interval
      if (currentState.step % reportInterval === 0 || currentState.isComplete) {
        const progressData: SAProgressData = {
          step: currentState.step,
          totalSteps: currentState.totalSteps,
          cycle: currentState.cycle,
          currentEnergy: currentState.currentEnergy,
          bestEnergy: currentState.bestEnergy,
          temperature: currentState.temperature,
          accepted: currentState.step > 0, // Approximate - use last step's accepted
          acceptedMoves: currentState.acceptedMoves,
          rejectedMoves: currentState.rejectedMoves,
          invalidMoves: currentState.invalidMoves,
          isComplete: currentState.isComplete,
        };
        await onProgress(progressData);
      }

      // Yield to event loop periodically (every 100 steps) to allow message processing
      // This ensures pause/resume messages can be received
      if (currentState.step % 100 === 0) {
        await new Promise<void>(resolve => setTimeout(resolve, 0));
      }
    }

    return this.engine.getResult();
  }

  pause(): void {
    this._isPaused = true;
  }

  resume(): void {
    this._isPaused = false;
  }

  isPaused(): boolean {
    return this._isPaused;
  }

  reset(): void {
    this.engine = null;
    this.params = null;
    this._isPaused = false;
  }
}

Comlink.expose(new SAWorker());
```

Key design decisions:
- **Singleton instance** exposed via Comlink (not the class) -- simpler lifecycle management
- **Pause uses setTimeout(0) loop** -- yields to event loop so postMessage from main thread (pause/resume) can be processed
- **Periodic yield every 100 steps** -- prevents worker from monopolizing CPU, allows message processing
- **Progress callback via Comlink.proxy** -- main thread wraps callback in Comlink.proxy() before passing
- **reportInterval parameter** -- defaults to 10 (20 updates per 200-step cycle), caller can adjust

IMPORTANT: The `accepted` field in SAProgressData is approximate in this implementation. If the exact per-step accepted flag is needed, the SAEngineState interface could be extended. For Phase 2 this approximation is fine (Phase 3 charting will use the full history array from SAResult).

After creating the worker, verify the full pipeline works by adding a smoke test to main.ts (temporary, will be replaced by Alpine.js UI in Plan 03):

Update src/main.ts to add a temporary smoke test function:
```typescript
// Temporary smoke test (will be replaced by Alpine.js UI in Plan 03)
async function smokeTest() {
  const proxy = await initWorker();
  await proxy.initialize({
    formula: 'C6H14',
    initialTemp: 100,
    coolingScheduleK: 8,
    stepsPerCycle: 50,
    numCycles: 2,
    optimizationMode: 'MINIMIZE',
    seed: 42
  });

  const result = await proxy.run(
    Comlink.proxy((progress) => {
      console.log(`Step ${progress.step}/${progress.totalSteps} | Energy: ${progress.currentEnergy} | Best: ${progress.bestEnergy}`);
    }),
    10
  );

  console.log('SA complete:', result.bestEnergy, 'accepted:', result.acceptedMoves);
  terminateWorker();
}

// Run smoke test on load
smokeTest().catch(console.error);
```

This verifies the full worker pipeline works end-to-end in the browser.
  </action>
  <verify>Run `npx vite build` (build succeeds with worker). Run `npx vite` and open browser console -- should see progress logs and final result. Run `npx vitest run` (all existing tests pass). Run `npx tsc --noEmit` (zero errors).</verify>
  <done>Web Worker runs SAEngine via Comlink. Progress callbacks report to main thread. Pause/resume mechanism works. Browser console shows step-by-step progress from worker.</done>
</task>

</tasks>

<verification>
```bash
# All existing tests pass
npx vitest run

# TypeScript clean
npx tsc --noEmit

# Vite builds successfully (includes worker)
npx vite build

# Dev server starts and worker executes (manual check: open browser, see console logs)
npx vite --open
```
</verification>

<success_criteria>
1. `npx vite build` succeeds with worker bundle included
2. Browser console shows progress messages from worker during SA execution
3. Main thread UI remains responsive during worker execution (no freeze)
4. Worker can be terminated cleanly via terminateWorker()
5. All 149+ existing tests pass (no regressions from dependency installation or scaffold)
</success_criteria>

<output>
After completion, create `.planning/phases/02-browser-integration-controls/02-02-SUMMARY.md`
</output>
