---
phase: 02-browser-integration-controls
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/SAEngine.ts
  - src/core/__tests__/SAEngine.test.ts
  - src/core/types.ts
autonomous: true

must_haves:
  truths:
    - "SAEngine exposes step-by-step execution API (init, step, getState, getResult)"
    - "Existing run() method still works identically (backward compatible)"
    - "Step-by-step execution produces same results as run() for same seed"
    - "External caller can pause between steps and resume later"
  artifacts:
    - path: "src/core/SAEngine.ts"
      provides: "Step-by-step SA execution methods"
      exports: ["SAEngine"]
      contains: "init("
    - path: "src/core/__tests__/SAEngine.test.ts"
      provides: "Tests for step-by-step API"
      contains: "step-by-step"
    - path: "src/core/types.ts"
      provides: "SAEngineState interface"
      contains: "SAEngineState"
  key_links:
    - from: "src/core/SAEngine.ts init()"
      to: "src/core/SAEngine.ts step()"
      via: "init() sets up state, step() advances one iteration"
      pattern: "init\\(|step\\("
    - from: "src/core/SAEngine.ts run()"
      to: "src/core/SAEngine.ts init() + step()"
      via: "run() delegates to init() then loops step()"
      pattern: "this\\.init\\(|this\\.step\\("
---

<objective>
Refactor SAEngine to expose a step-by-step execution API for Web Worker integration.

Purpose: The current SAEngine.run() is a blocking loop that cannot be paused, resumed, or report progress mid-execution. Phase 2 needs step-by-step control so the Web Worker can: (a) report progress to the UI every N steps, (b) pause/resume on user command, and (c) yield control back to the event loop between steps.

Output: SAEngine with new public methods (init, step, getState, getResult) alongside the existing run(), all fully tested.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/core/SAEngine.ts
@src/core/types.ts
@src/core/__tests__/SAEngine.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for step-by-step API</name>
  <files>src/core/__tests__/SAEngine.test.ts, src/core/types.ts</files>
  <action>
Add a new `SAEngineState` interface to `src/core/types.ts`:
```typescript
export interface SAEngineState {
  step: number;
  totalSteps: number;
  cycle: number;
  currentEnergy: number;
  bestEnergy: number;
  temperature: number;
  acceptedMoves: number;
  rejectedMoves: number;
  invalidMoves: number;
  isComplete: boolean;
}
```

Add a new describe block "SAEngine step-by-step execution" in the test file with these tests:

1. **init() sets up initial state**: Create engine, call init(), verify getState() returns step=0, isComplete=false, and currentEnergy/bestEnergy are equal (initial structure computed).

2. **step() advances one iteration**: After init(), call step() once, verify getState().step === 1.

3. **step() throws if init() not called**: Calling step() before init() should throw Error.

4. **Multiple steps execute correctly**: Call step() N times, verify state.step === N.

5. **isComplete becomes true after all steps**: For engine with stepsPerCycle=10, numCycles=1 (10 total steps), call step() 10 times. Verify getState().isComplete === true.

6. **step() throws after completion**: Call step() after isComplete=true, should throw Error.

7. **getResult() returns final result after completion**: After all steps, getResult() should return SAResult with correct fields.

8. **getResult() throws if not complete**: Call getResult() before completion, should throw Error.

9. **Step-by-step matches run() for same seed**: Create two engines with identical params and seed. One uses run(), other uses init() + loop of step() + getResult(). Both should produce identical bestEnergy, acceptedMoves, rejectedMoves, invalidMoves.

10. **run() still works unchanged**: Verify existing run() behavior is preserved (existing tests already cover this, but add one explicit backward-compatibility test).

Use params: formula='C6H14', initialTemp=100, coolingScheduleK=8, stepsPerCycle=50, numCycles=2, optimizationMode='MINIMIZE', seed=42. Use smaller step counts for faster test execution.

All tests should FAIL because init(), step(), getState(), getResult() don't exist yet.
  </action>
  <verify>Run `npx vitest run`. New tests fail (methods don't exist). All 139 existing tests still pass.</verify>
  <done>10+ new failing tests for step-by-step API. Zero regressions on existing tests.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN+REFACTOR - Implement step-by-step API</name>
  <files>src/core/SAEngine.ts</files>
  <action>
Add four new public methods to SAEngine:

**init()**: Move the initialization logic from run() into init():
- Parse formula and generate initial structure
- Compute initial Wiener Index
- Set bestGraph = currentGraph.clone(), bestEnergy = currentEnergy
- Compute totalSteps = stepsPerCycle * numCycles
- Set globalStep = 0
- Add a private `initialized: boolean = false` flag, set to true after init()
- Add a private `completed: boolean = false` flag

**step()**: Execute a single SA iteration:
- Throw if not initialized or already completed
- Increment globalStep
- Compute current temperature using computeTemperature(globalStep - 1, totalSteps, initialTemp, coolingScheduleK)
- Call the existing private iterate(temperature, globalStep) method
- If globalStep === totalSteps, set completed = true
- Return void (state accessed via getState())

**getState()**: Return current SAEngineState snapshot:
- Throw if not initialized
- Return object with: step (globalStep), totalSteps, cycle (Math.floor((globalStep - 1) / stepsPerCycle) + 1, or 0 if step 0), currentEnergy, bestEnergy, temperature (current), acceptedMoves, rejectedMoves, invalidMoves, isComplete (completed flag)

**getResult()**: Return SAResult (same as current run() return):
- Throw if not completed
- Return the same SAResult object that run() currently builds

**Refactor run()**: Rewrite run() to delegate to the new methods:
```typescript
run(): SAResult {
  this.init();
  while (!this.completed) {
    this.step();
  }
  return this.getResult();
}
```

This ensures run() and step-by-step execution use identical code paths.

Make the `totalSteps`, `globalStep`, `initialized`, and `completed` fields private class members (not local to run()). The `currentTemperature` should also be tracked as a field so getState() can return it.

IMPORTANT: Keep all existing private methods (iterate, metropolisAccept, isBetter, recordStep) unchanged. The refactor only changes how the outer loop works.
  </action>
  <verify>Run `npx vitest run`. ALL tests pass (139 existing + 10+ new). Run `npx tsc --noEmit` for zero TypeScript errors.</verify>
  <done>SAEngine has init(), step(), getState(), getResult() methods. run() delegates to them. All tests pass. Step-by-step and run() produce identical results for same seed.</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
npx vitest run

# TypeScript clean
npx tsc --noEmit

# Specific step-by-step tests pass
npx vitest run -t "step-by-step"
```
</verification>

<success_criteria>
1. SAEngine.init() + repeated step() + getResult() produces identical results to run() for same parameters and seed
2. getState() returns accurate snapshot at any point during execution
3. step() can be called one-at-a-time with arbitrary delays between calls (enabling pause/resume)
4. All 139+ existing tests pass without modification (backward compatible)
5. 10+ new tests for step-by-step API all pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-browser-integration-controls/02-01-SUMMARY.md`
</output>
