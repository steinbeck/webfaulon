---
phase: 04-backend-core-rdkit-foundation
plan: 03
type: tdd
wave: 2
depends_on: ["04-02"]
files_modified:
  - backend/app/core/molecule.py
  - backend/app/core/displacement.py
  - backend/app/core/wiener.py
  - backend/app/core/initial_structure.py
  - backend/app/utils/rdkit_helpers.py
  - backend/tests/test_molecule.py
  - backend/tests/test_displacement.py
  - backend/tests/test_wiener.py
  - backend/tests/test_initial_structure.py
autonomous: true
user_setup:
  - service: rdkit
    why: "Python RDKit is required for molecular operations"
    env_vars: []
    dashboard_config:
      - task: "Install RDKit in the backend virtual environment"
        location: "Run: cd backend && pip install rdkit (or conda install -c conda-forge rdkit)"
must_haves:
  truths:
    - "MoleculeGraph wrapper provides get_bond_order, set_bond, is_connected, clone matching TypeScript MolGraph behavior"
    - "Faulon displacement on RDKit RWMol preserves valence rules and connectivity (validated by SanitizeMol)"
    - "Wiener Index via RDKit distance matrix matches v1.0 values: linear hexane=35, cyclohexane=27, isobutane=9, neopentane=16"
    - "Initial structure from C6H14 produces connected 6-carbon molecule with 14 implicit hydrogens"
    - "Canonical SMILES generated via RDKit MolToSmiles for any valid molecule"
    - "500 consecutive displacements on hexane produce zero invalid molecules"
  artifacts:
    - path: "backend/app/core/molecule.py"
      provides: "RDKit Mol wrapper with adjacency-matrix-like API"
      contains: "class MoleculeGraph"
    - path: "backend/app/core/displacement.py"
      provides: "Faulon displacement equations 7-11 on RDKit molecules"
      contains: "def attempt_displacement"
    - path: "backend/app/core/wiener.py"
      provides: "Wiener Index via RDKit GetDistanceMatrix"
      contains: "def compute_wiener_index"
    - path: "backend/app/core/initial_structure.py"
      provides: "Deterministic initial structure generation from formula"
      contains: "def generate_initial_structure"
    - path: "backend/app/utils/rdkit_helpers.py"
      provides: "BondType mapping and sanitization utilities"
      contains: "def order_to_bond_type"
    - path: "backend/tests/test_displacement.py"
      provides: "Displacement stress tests ported from TypeScript"
      min_lines: 80
    - path: "backend/tests/test_wiener.py"
      provides: "Wiener Index known-value tests"
      min_lines: 50
  key_links:
    - from: "backend/app/core/displacement.py"
      to: "backend/app/core/molecule.py"
      via: "MoleculeGraph.set_bond and get_bond_order calls"
      pattern: "MoleculeGraph"
    - from: "backend/app/core/displacement.py"
      to: "backend/app/core/random.py"
      via: "SeededRandom for atom selection"
      pattern: "SeededRandom"
    - from: "backend/app/core/wiener.py"
      to: "rdkit.Chem.GetDistanceMatrix"
      via: "RDKit distance matrix for Wiener computation"
      pattern: "GetDistanceMatrix"
    - from: "backend/app/core/initial_structure.py"
      to: "backend/app/core/formula_parser.py"
      via: "parse_formula for atom counts"
      pattern: "parse_formula"
    - from: "backend/app/core/molecule.py"
      to: "backend/app/utils/rdkit_helpers.py"
      via: "BondType mapping for set_bond"
      pattern: "order_to_bond_type"
---

<objective>
Port the RDKit-dependent molecular modules (MoleculeGraph wrapper, Faulon displacement, Wiener Index, initial structure generation) from TypeScript to Python using TDD. This is the critical plan that validates the TypeScript-to-RDKit translation.

Purpose: The Faulon displacement operating on RDKit RWMol is the highest-risk component of the entire v2.0 migration. Porting with TDD and validating against v1.0 test values ensures chemical correctness before building the SA engine on top.
Output: Four tested Python modules that provide the molecular foundation for SAEngine.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-backend-core-rdkit-foundation/04-RESEARCH.md
@.planning/phases/04-backend-core-rdkit-foundation/04-02-SUMMARY.md
@src/core/MolGraph.ts
@src/core/__tests__/MolGraph.test.ts
@src/core/displacement.ts
@src/core/__tests__/displacement.test.ts
@src/core/wiener.ts
@src/core/__tests__/wiener.test.ts
@src/core/initialStructure.ts
@src/core/__tests__/initialStructure.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RDKit helpers, MoleculeGraph wrapper, and Wiener Index (TDD)</name>
  <files>
    backend/app/utils/rdkit_helpers.py
    backend/app/core/molecule.py
    backend/app/core/wiener.py
    backend/tests/test_molecule.py
    backend/tests/test_wiener.py
  </files>
  <action>
    PREREQUISITE: Ensure RDKit is installed in the backend venv. Run `cd backend && pip install rdkit` (or `poetry run pip install rdkit`). Verify with `poetry run python -c "from rdkit import Chem; print(Chem.MolToSmiles(Chem.MolFromSmiles('CCO')))"` which should print "CCO".

    **RDKit Helpers:**

    Create `backend/app/utils/rdkit_helpers.py`:
    - `order_to_bond_type(order: int) -> Chem.BondType`: Map Faulon integer (0,1,2,3) to RDKit BondType enum. Use explicit dict mapping, NOT direct cast. Raise ValueError for invalid orders.
    - `bond_type_to_order(bond_type: Chem.BondType) -> int`: Reverse mapping.

    **MoleculeGraph Wrapper (RED-GREEN-REFACTOR):**

    RED: Create `backend/tests/test_molecule.py` ported from `src/core/__tests__/MolGraph.test.ts`:
    - `test_create_linear_alkane_methane`: 1 atom, no bonds, 4 implicit H (RDKit handles this via GetNumImplicitHs)
    - `test_create_linear_alkane_ethane`: 2 atoms, single bond, 3 implicit H each
    - `test_create_linear_alkane_pentane`: 5 atoms, terminal H=3, internal H=2
    - `test_create_linear_alkane_decane`: 10 atoms, connected
    - `test_create_cyclohexane`: 6 atoms, each bonded to 2 neighbors, connected
    - `test_create_isobutane`: 4 atoms, central atom has 3 bonds
    - `test_create_neopentane`: 5 atoms, central atom has 4 bonds
    - `test_connectivity_connected`: Linear pentane is connected
    - `test_connectivity_disconnected`: Two separate fragments are not connected
    - `test_connectivity_single_atom`: Single atom is connected
    - `test_valid_valences_alkane`: Linear pentane has valid valences
    - `test_set_bond_updates_order`: Setting bond from 1 to 2 changes bond order
    - `test_set_bond_symmetric`: Setting bond(0,1,2) means both get_bond_order(0,1) and (1,0) return 2
    - `test_clone_independent`: Modifying clone doesn't affect original
    - `test_to_smiles`: Linear hexane produces canonical SMILES
    - `test_get_implicit_h`: Verify implicit hydrogen counts match TypeScript values

    GREEN: Create `backend/app/core/molecule.py`:

    The key design decision: Unlike TypeScript's adjacency-matrix MolGraph, this wraps RDKit's native Mol object. The API should feel similar but leverage RDKit internally.

    ```python
    class MoleculeGraph:
        """RDKit Mol wrapper providing adjacency-matrix-like API for Faulon SA."""

        def __init__(self, mol: Chem.Mol):
            """Initialize from an RDKit Mol (makes deep copy)."""
            self._mol = Chem.RWMol(Chem.Mol(mol))

        # Properties
        def get_atom_count(self) -> int
        def get_bond_order(self, i: int, j: int) -> int  # 0 if no bond
        def get_bond_order_sum(self, atom_index: int) -> int
        def get_implicit_h(self, atom_index: int) -> int
        def get_atom_element(self, atom_index: int) -> str

        # Mutation
        def set_bond(self, i: int, j: int, order: int) -> None
            # If order == 0: remove bond if exists
            # If no existing bond and order > 0: add bond with order_to_bond_type(order)
            # If existing bond: set bond type to order_to_bond_type(order)
            # CRITICAL: Call Chem.SanitizeMol() after modification
            # If sanitization fails, raise ValueError

        # Validation
        def is_connected(self) -> bool  # Use Chem.GetMolFrags
        def has_valid_valences(self) -> bool  # Try SanitizeMol
        def validate(self) -> dict  # {"connected": bool, "valid_valences": bool}

        # Utilities
        def clone(self) -> 'MoleculeGraph'  # Deep copy
        def to_smiles(self) -> str  # Chem.MolToSmiles
        def get_mol(self) -> Chem.Mol  # Return immutable copy

        # Factory methods (class methods)
        @classmethod
        def create_linear_alkane(cls, n: int) -> 'MoleculeGraph'
        @classmethod
        def create_cyclohexane(cls) -> 'MoleculeGraph'
        @classmethod
        def create_branched(cls, pattern: str) -> 'MoleculeGraph'
    ```

    IMPORTANT for set_bond(): When order is 0, you must REMOVE the bond (not set to UNSPECIFIED). When setting a non-zero order where no bond exists, you must ADD the bond first. The SanitizeMol call after modification is mandatory per research pitfall #1.

    IMPORTANT for factory methods: Create RWMol, add atoms with `Chem.Atom('C')`, add bonds with `mol.AddBond(i, j, BondType.SINGLE)`, then convert to Mol and sanitize.

    NOTE on implicit H: RDKit computes implicit H automatically after sanitization. Access via `mol.GetAtomWithIdx(i).GetNumImplicitHs()`. This replaces TypeScript's manual `standardValence - bondOrderSum` calculation.

    **Wiener Index (RED-GREEN-REFACTOR):**

    RED: Create `backend/tests/test_wiener.py` ported from `src/core/__tests__/wiener.test.ts`:
    - `test_methane_wiener_0`: Single atom -> 0
    - `test_ethane_wiener_1`: 2-carbon chain -> 1
    - `test_propane_wiener_4`: 3-carbon chain -> 4
    - `test_butane_wiener_10`: 4-carbon chain -> 10
    - `test_pentane_wiener_20`: 5-carbon chain -> 20
    - `test_hexane_wiener_35`: 6-carbon chain -> 35
    - `test_cyclohexane_wiener_27`: Cyclohexane ring -> 27
    - `test_isobutane_wiener_9`: Branched isobutane -> 9
    - `test_neopentane_wiener_16`: Branched neopentane -> 16
    - `test_linear_formula_n7`: n=7 -> 56
    - `test_linear_formula_n8`: n=8 -> 84
    - `test_linear_formula_n10`: n=10 -> 165
    - `test_disconnected_raises`: Disconnected graph raises error

    GREEN: Create `backend/app/core/wiener.py`:
    ```python
    def compute_wiener_index(mol_graph: MoleculeGraph) -> float:
        """Compute Wiener Index using RDKit GetDistanceMatrix."""
        mol = mol_graph.get_mol()
        dist_matrix = Chem.GetDistanceMatrix(mol)
        n = mol.GetNumAtoms()
        # Sum upper triangle
        wiener = sum(
            dist_matrix[i][j]
            for i in range(n)
            for j in range(i + 1, n)
        )
        return wiener
    ```
    NOTE: Use `Chem.GetDistanceMatrix()` instead of custom BFS (research: "Don't Hand-Roll" section). Check for disconnected molecules (distance matrix will have large/inf values).
  </action>
  <verify>
    ```
    cd backend && poetry run pytest tests/test_molecule.py tests/test_wiener.py -v
    ```
    All tests pass. Wiener Index values match TypeScript exactly.
  </verify>
  <done>
    MoleculeGraph provides adjacency-matrix-like API over RDKit. Wiener Index computed via RDKit distance matrix matches all v1.0 reference values. Factory methods create correct molecular structures. SanitizeMol called after every bond modification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Displacement and initial structure generation (TDD)</name>
  <files>
    backend/app/core/displacement.py
    backend/app/core/initial_structure.py
    backend/tests/test_displacement.py
    backend/tests/test_initial_structure.py
  </files>
  <action>
    **Faulon Displacement (RED-GREEN-REFACTOR):**

    RED: Create `backend/tests/test_displacement.py` ported from `src/core/__tests__/displacement.test.ts`:
    - `test_null_for_less_than_4_atoms`: Methane, ethane, propane all return None
    - `test_preserves_atom_count`: 100 displacements on hexane, all results have 6 atoms
    - `test_preserves_atom_types`: All atoms remain carbon
    - `test_does_not_mutate_original`: Original graph unchanged after displacement
    - `test_bond_orders_in_range`: 200 displacements, all bond orders in [0, 3]
    - `test_handles_existing_double_bonds`: Molecule with C=C-C-C
    - `test_only_connected_or_null`: 200 displacements, result is connected or None
    - `test_only_valid_valences_or_null`: 200 displacements, result has valid valences or None
    - `test_produces_some_valid_displacements`: At least some succeed on hexane
    - `test_rejects_disconnecting_moves`: 4-atom chain, all results connected
    - `test_reproducible_same_seed`: Seed 12345 produces identical results twice
    - `test_different_seeds_differ`: Seeds 111 vs 222 produce different results
    - `test_stress_500_displacements`: 500 iterations on hexane, zero invalid molecules, some valid
    - `test_cyclohexane_displacement`: Cyclic structure displacement works
    - `test_bond_conservation_equations`: 4-atom molecule, equations produce valid results

    GREEN: Create `backend/app/core/displacement.py`:

    Port `attemptDisplacement` and `computeDisplacementBonds` from `src/core/displacement.ts`:

    ```python
    MAX_BOND_ORDER = 3
    MIN_ATOMS_FOR_DISPLACEMENT = 4

    def compute_displacement_bonds(
        a11: int, a12: int, a21: int, a22: int,
        rng: SeededRandom
    ) -> dict | None:
        """Compute new bond orders via Faulon equations 7-11."""
        # Equation 10: b11_min
        b11_min = max(0, a11 - a22, a11 - a12, a11 + a12 - 3, a11 + a21 - 3)
        # Equation 11: b11_max
        b11_max = min(3, a11 + a12, a11 + a21, a11 - a22 + 3)

        if b11_min > b11_max:
            return None

        b11 = rng.next_int(b11_min, b11_max)
        b12 = a11 + a12 - b11  # Eq 7
        b21 = a11 + a21 - b11  # Eq 8
        b22 = a22 - a11 + b11  # Eq 9

        # Safety check
        for b in [b11, b12, b21, b22]:
            if b < 0 or b > MAX_BOND_ORDER:
                raise RuntimeError(f"Bond order out of range: {b}")

        return {"b11": b11, "b12": b12, "b21": b21, "b22": b22}

    def attempt_displacement(
        mol_graph: MoleculeGraph,
        rng: SeededRandom
    ) -> MoleculeGraph | None:
        """Attempt Faulon displacement. Returns new graph or None."""
        atom_count = mol_graph.get_atom_count()
        if atom_count < MIN_ATOMS_FOR_DISPLACEMENT:
            return None

        selected = rng.select_n_distinct(4, atom_count)
        x1, y1, x2, y2 = selected[0], selected[1], selected[2], selected[3]

        # Read current bond orders
        a11 = mol_graph.get_bond_order(x1, y1)
        a12 = mol_graph.get_bond_order(y1, y2)
        a21 = mol_graph.get_bond_order(x1, x2)
        a22 = mol_graph.get_bond_order(x2, y2)

        new_bonds = compute_displacement_bonds(a11, a12, a21, a22, rng)
        if new_bonds is None:
            return None

        # Clone and apply
        new_graph = mol_graph.clone()
        try:
            new_graph.set_bond(x1, y1, new_bonds["b11"])
            new_graph.set_bond(y1, y2, new_bonds["b12"])
            new_graph.set_bond(x1, x2, new_bonds["b21"])
            new_graph.set_bond(x2, y2, new_bonds["b22"])
        except ValueError:
            return None  # SanitizeMol failed

        if not new_graph.is_connected() or not new_graph.has_valid_valences():
            return None

        return new_graph
    ```

    IMPORTANT: The set_bond calls may raise ValueError if SanitizeMol fails after individual bond changes. This is the key difference from TypeScript -- RDKit validates after EACH modification, not just at the end. If intermediate states are invalid, you may need to apply all 4 bond changes on the RWMol BEFORE sanitizing. Consider an alternative approach:

    Instead of calling set_bond (which sanitizes after each call), create a lower-level `_apply_displacement_bonds` method on MoleculeGraph that:
    1. Creates RWMol copy
    2. Applies all 4 bond changes WITHOUT intermediate sanitization
    3. Sanitizes ONCE at the end
    4. Returns new MoleculeGraph if valid, None if not

    This matches the TypeScript behavior where setBond doesn't validate, and validation happens after all bonds are set.

    Decide which approach works: test both if needed. The key constraint is that the final molecule must pass SanitizeMol.

    **Initial Structure Generation (RED-GREEN-REFACTOR):**

    RED: Create `backend/tests/test_initial_structure.py` ported from `src/core/__tests__/initialStructure.test.ts`:
    - `test_hexane_structure`: C6H14 -> 6 atoms, all C, connected, valid valences, 14 implicit H
    - `test_butane_structure`: C4H10 -> 4 atoms, 10 implicit H
    - `test_methane_structure`: CH4 -> 1 atom, 4 implicit H
    - `test_unsaturation_hdi_1`: C6H12 -> 6 atoms, 12 implicit H, at least one double bond
    - `test_unsaturation_hdi_4`: C6H6 -> 6 atoms, 6 implicit H
    - `test_heteroatom_oxygen`: C2H6O -> 3 atoms (2C + 1O), 6 implicit H
    - `test_heteroatom_nitrogen`: C2H7N -> 3 atoms, 7 implicit H
    - `test_ethene`: C2H4 -> 2 atoms, double bond, 4 implicit H
    - `test_ethyne`: C2H2 -> 2 atoms, triple bond, 2 implicit H
    - `test_empty_formula_raises`: Empty string raises error
    - `test_impossible_formula_raises`: C6H99 raises error
    - `test_deterministic`: Same formula produces same structure
    - `test_h2_no_heavy_atoms`: H2 -> 0 heavy atoms

    GREEN: Create `backend/app/core/initial_structure.py`:
    Port `generateInitialStructure` from `src/core/initialStructure.ts`.

    Key adaptation: Instead of building an adjacency matrix, build an RDKit RWMol directly:
    1. Parse formula to get atom counts
    2. Create RWMol, add heavy atoms in deterministic order (C, N, O, S, P, then halogens)
    3. Add single bonds in linear chain (atom i to atom i+1)
    4. Add unsaturation: upgrade bonds to satisfy HDI (same algorithm as TypeScript)
    5. Sanitize and wrap in MoleculeGraph
    6. Verify implicit H count matches formula

    NOTE: RDKit handles implicit H automatically. After sanitization, check total implicit H via `sum(mol.GetAtomWithIdx(i).GetNumImplicitHs() for i in range(mol.GetNumAtoms()))`.
  </action>
  <verify>
    ```
    cd backend && poetry run pytest tests/test_displacement.py tests/test_initial_structure.py -v
    ```
    All tests pass. 500-displacement stress test produces zero invalid molecules.
  </verify>
  <done>
    Faulon displacement operates on RDKit RWMol with SanitizeMol validation after every move. 500 consecutive displacements on hexane produce zero invalid molecules. Initial structure generation produces valid connected molecules with correct hydrogen counts. All test values match v1.0 TypeScript reference.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && poetry run pytest tests/test_molecule.py -v` -- all pass
2. `cd backend && poetry run pytest tests/test_wiener.py -v` -- Wiener values match: hexane=35, cyclohexane=27, isobutane=9, neopentane=16
3. `cd backend && poetry run pytest tests/test_displacement.py -v` -- 500-displacement stress test passes
4. `cd backend && poetry run pytest tests/test_initial_structure.py -v` -- all formulas produce valid structures
5. `cd backend && poetry run python -c "from app.core.molecule import MoleculeGraph; m = MoleculeGraph.create_linear_alkane(6); print(m.to_smiles())"` -- prints valid SMILES
</verification>

<success_criteria>
- MoleculeGraph wraps RDKit Mol with clean API matching TypeScript MolGraph interface
- Faulon displacement on RDKit RWMol preserves valence rules (SanitizeMol validates)
- Wiener Index via GetDistanceMatrix matches all v1.0 reference values
- Initial structure from formula is connected, valid, and deterministic
- Canonical SMILES produced via RDKit MolToSmiles
- All ported test suites pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-backend-core-rdkit-foundation/04-03-SUMMARY.md`
</output>
