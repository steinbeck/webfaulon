---
phase: 03-visualization-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/chart.ts
  - src/ui/molecule-renderer.ts
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "Chart.js is installed and can be imported"
    - "Chart module creates a line chart on a canvas element without Alpine reactive conflicts"
    - "Molecule renderer can render a SMILES string to a canvas element using RDKit.js"
    - "Both modules store instances outside any reactive framework scope"
  artifacts:
    - path: "src/ui/chart.ts"
      provides: "Chart.js line chart creation and update functions"
      exports: ["createWienerChart", "addChartDataPoint", "resetChart", "destroyChart"]
    - path: "src/ui/molecule-renderer.ts"
      provides: "RDKit.js 2D molecule rendering to canvas"
      exports: ["renderMolecule", "clearMoleculeCanvas"]
    - path: "package.json"
      provides: "chart.js dependency"
      contains: "chart.js"
  key_links:
    - from: "src/ui/chart.ts"
      to: "chart.js"
      via: "tree-shaken import of Chart components"
      pattern: "import.*from.*chart.js"
    - from: "src/ui/molecule-renderer.ts"
      to: "window.__rdkit"
      via: "RDKit global loaded by script tag"
      pattern: "__rdkit"
---

<objective>
Create the Chart.js live chart module and RDKit.js molecule renderer module as standalone functions ready for UI integration.

Purpose: These visualization modules must be created OUTSIDE Alpine.js reactive scope (module-level, not inside x-data) to avoid Proxy-of-Proxy conflicts. Creating them as standalone modules with clean APIs lets plan 03 wire them into the UI without worrying about reactive framework conflicts.

Output: Two new modules (chart.ts, molecule-renderer.ts) with clean export APIs, plus Chart.js npm dependency installed.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-visualization-ux/03-RESEARCH.md
@src/ui/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Chart.js and create live chart module</name>
  <files>src/ui/chart.ts, package.json, package-lock.json</files>
  <action>
**1. Install Chart.js:**
```bash
npm install chart.js
```

**2. Create src/ui/chart.ts:**

Tree-shake Chart.js by registering only needed components (do NOT use `import Chart from 'chart.js/auto'`):

```typescript
import {
  Chart,
  LineController,
  LineElement,
  PointElement,
  LinearScale,
  Filler,
  Tooltip,
  DecimationPlugin,
} from 'chart.js';
```

Register these components: `Chart.register(LineController, LineElement, PointElement, LinearScale, Filler, Tooltip, DecimationPlugin);`

**Module-level chart instance** (CRITICAL: NOT inside Alpine reactive data):
```typescript
let _chartInstance: Chart | null = null;
```

**Exported functions:**

`createWienerChart(canvas: HTMLCanvasElement): void`
- If `_chartInstance` exists, destroy it first (clean up old chart)
- Create new Chart instance on the canvas with these options:
  - type: 'line'
  - dataset label: 'Wiener Index'
  - line color: 'rgb(59, 130, 246)' (blue-500)
  - fill below line with 'rgba(59, 130, 246, 0.1)'
  - borderWidth: 2
  - pointRadius: 0 (disable point rendering for performance)
  - tension: 0 (straight lines, required for decimation)
  - animation: false (CRITICAL for real-time performance)
  - parsing: false (CRITICAL: provide pre-parsed {x, y} data)
  - responsive: true
  - maintainAspectRatio: true
  - aspectRatio: 2.5 (wide chart for step timeline)
  - decimation plugin enabled with algorithm: 'min-max' (preserves SA peaks/valleys)
  - legend: display false (single dataset, label not needed)
  - x scale: type 'linear', title 'Step', font size 14
  - y scale: type 'linear', title 'Wiener Index', font size 14
  - tooltip enabled (shows data on hover)

`addChartDataPoint(step: number, wienerIndex: number): void`
- If no chart instance, return silently
- Push `{x: step, y: wienerIndex}` to dataset[0].data
- Call `_chartInstance.update('none')` ('none' mode = no animation, fastest)

`resetChart(): void`
- If no chart instance, return silently
- Clear dataset[0].data to empty array
- Call `_chartInstance.update('none')`

`destroyChart(): void`
- If chart instance exists, call `.destroy()` and set `_chartInstance` to null
  </action>
  <verify>
Verify `npm ls chart.js` shows chart.js installed.
Verify `npx tsc --noEmit` passes (types resolve correctly).
Verify src/ui/chart.ts exports createWienerChart, addChartDataPoint, resetChart, destroyChart.
  </verify>
  <done>Chart.js is installed. chart.ts module exports 4 functions for chart lifecycle management. Chart instance is stored at module level (not in Alpine reactive scope). TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create RDKit.js molecule renderer module</name>
  <files>src/ui/molecule-renderer.ts</files>
  <action>
Create src/ui/molecule-renderer.ts with functions for rendering 2D molecular structures using RDKit.js.

**Module-level state:**
```typescript
let _lastRenderedSMILES: string | null = null;
```
This tracks the last rendered SMILES to avoid redundant re-renders (only re-render when bestEnergy changes, which implies a new best structure).

**Exported functions:**

`renderMolecule(smiles: string, canvas: HTMLCanvasElement): boolean`
- If `smiles === _lastRenderedSMILES`, return false (skip redundant render)
- Get RDKit from `(window as any).__rdkit`
- If RDKit not available, log warning and return false
- In a try/finally block:
  - `mol = RDKit.get_mol(smiles)`
  - If mol is null or `!mol.is_valid()`, throw error
  - Clear canvas: `ctx.clearRect(0, 0, canvas.width, canvas.height)`
  - Call `mol.draw_to_canvas(canvas, -1, -1)` (-1, -1 = use full canvas dimensions)
  - Update `_lastRenderedSMILES = smiles`
  - Return true
  - In finally: call `mol.delete()` if mol exists (CRITICAL: prevent WASM memory leak)
- In catch block: render error fallback on canvas (red text "Could not render molecule"), return false

`clearMoleculeCanvas(canvas: HTMLCanvasElement): void`
- Get 2d context from canvas
- Clear entire canvas rect
- Reset `_lastRenderedSMILES` to null
- Draw placeholder text in gray: "No structure yet" centered on canvas

**Important notes:**
- Always call `mol.delete()` — this is mandatory for WASM memory management
- The try/finally pattern ensures cleanup even on rendering errors
- The `_lastRenderedSMILES` check prevents redundant RDKit calls (SMILES only changes when bestEnergy improves, which is infrequent relative to total progress callbacks)
- Canvas dimensions should be set in HTML (width/height attributes), not CSS, for proper RDKit rendering
  </action>
  <verify>
Verify `npx tsc --noEmit` passes (types resolve correctly).
Verify src/ui/molecule-renderer.ts exports renderMolecule and clearMoleculeCanvas.
  </verify>
  <done>molecule-renderer.ts module exports renderMolecule and clearMoleculeCanvas functions. WASM memory cleanup is guaranteed via try/finally. Redundant re-renders are prevented by SMILES comparison. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npm ls chart.js` — chart.js appears in dependencies
2. `npx tsc --noEmit` — no type errors
3. `npx vitest run` — all existing tests still pass (no regressions from new dependencies)
4. Both modules export clean APIs with module-level instance storage
</verification>

<success_criteria>
- Chart.js installed and importable
- chart.ts creates performant line chart with decimation, animation disabled, stored outside reactive scope
- molecule-renderer.ts renders SMILES to canvas via RDKit with proper WASM memory cleanup
- Both modules have clean exported APIs ready for UI integration
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualization-ux/03-02-SUMMARY.md`
</output>
