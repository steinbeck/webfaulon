---
phase: 07-multi-component-target-function
plan: 02
type: tdd
wave: 2
depends_on: ["07-01"]
files_modified:
  - backend/app/models/sa_params.py
  - backend/app/core/sa_engine.py
  - backend/tests/test_sa_engine.py
  - backend/tests/test_scoring_integration.py
autonomous: true

must_haves:
  truths:
    - "SA engine evaluates a weighted sum of scoring components instead of hardcoded compute_wiener_index()"
    - "Default component_weights={'wiener_index': 1.0} produces identical results to the current SA engine (backward compatible)"
    - "Multiple components with non-zero weights each contribute to the overall energy via weighted sum"
    - "Components with zero weight are skipped (not computed)"
    - "Unknown component names in component_weights are rejected at SAEngine.__init__() with clear error"
    - "SAParams with no component_weights specified defaults to {'wiener_index': 1.0}"
    - "Negative weights and all-zero weights are rejected by SAParams validation"
  artifacts:
    - path: "backend/app/models/sa_params.py"
      provides: "SAParams extended with component_weights: dict[str, float] field"
      contains: "component_weights"
    - path: "backend/app/core/sa_engine.py"
      provides: "SAEngine with _compute_energy() method and component registry integration"
      contains: "_compute_energy"
    - path: "backend/tests/test_scoring_integration.py"
      provides: "Integration tests for multi-component SA engine"
  key_links:
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/scoring/registry.py"
      via: "SAEngine.__init__() calls get_registry() and validates component_weights"
      pattern: "get_registry"
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/scoring/protocol.py"
      via: "_compute_energy() loops over components calling compute()"
      pattern: "component\\.compute"
    - from: "backend/app/models/sa_params.py"
      to: "backend/app/core/scoring/registry.py"
      via: "component_weights keys reference registered component names"
      pattern: "component_weights"
---

<objective>
Integrate the scoring component framework into SAEngine and SAParams, replacing the hardcoded `compute_wiener_index()` call with a weighted sum of pluggable components.

Purpose: Complete Phase 7 requirements TGT-01 and TGT-03 -- SA optimization supports multiple scoring components with configurable weights.
Output: Refactored SAEngine + extended SAParams, with full backward compatibility and new integration tests.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-component-target-function/07-RESEARCH.md
@.planning/phases/07-multi-component-target-function/07-01-SUMMARY.md
@backend/app/core/sa_engine.py
@backend/app/models/sa_params.py
@backend/tests/test_sa_engine.py
@backend/app/api/sa_configure.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for SA engine multi-component integration</name>
  <files>
    backend/tests/test_scoring_integration.py
  </files>
  <action>
Create `backend/tests/test_scoring_integration.py` with these test classes:

**TestSAParamsComponentWeights:**
- `test_default_weights`: `SAParams(formula="C6H14")` has `component_weights == {"wiener_index": 1.0}`
- `test_custom_weights`: `SAParams(formula="C6H14", component_weights={"wiener_index": 0.7, "logp": 0.3})` succeeds
- `test_negative_weight_rejected`: `SAParams(formula="C6H14", component_weights={"wiener_index": -1.0})` raises `ValidationError`
- `test_all_zero_weights_rejected`: `SAParams(formula="C6H14", component_weights={"wiener_index": 0.0})` raises `ValidationError`
- `test_empty_weights_rejected`: `SAParams(formula="C6H14", component_weights={})` raises `ValidationError`

**TestSAEngineWeightedEnergy:**
- `test_default_weights_match_original`: Run SAEngine with default params (seed=42, C6H14, 100 steps x 2 cycles). Compare result against a run using the current hardcoded engine -- both should produce identical `best_energy`, `accepted_moves`, `rejected_moves`, `invalid_moves`. (To test backward compatibility, first capture the values from the current engine before modifying it -- OR rely on known deterministic values from existing test_sa_engine.py. The key assertion is that `result.initial_energy == 35` which confirms Wiener Index is used.)
- `test_wiener_only_weight_1`: SAParams with `component_weights={"wiener_index": 1.0}` produces `initial_energy == 35` (linear hexane Wiener Index).
- `test_wiener_weight_2_doubles_energy`: SAParams with `component_weights={"wiener_index": 2.0}` produces `initial_energy == 70` (35 * 2.0).
- `test_two_components_combined`: SAParams with `component_weights={"wiener_index": 1.0, "logp": 1.0}`. Compute expected LogP of linear hexane via `Descriptors.MolLogP()` on a test mol. Assert `initial_energy == pytest.approx(35 + logp_value, abs=0.01)`. Use `pytest.approx()`.
- `test_zero_weight_component_excluded`: SAParams with `component_weights={"wiener_index": 1.0, "logp": 0.0}` produces `initial_energy == 35` (LogP has zero weight, so only Wiener contributes).

**TestSAEngineValidation:**
- `test_unknown_component_raises`: `SAEngine(SAParams(formula="C6H14", component_weights={"nonexistent": 1.0}))` raises `ValueError` with "Unknown scoring component" in message.
- `test_unknown_component_lists_available`: The ValueError message from above includes "wiener_index" and "logp".

**TestSAEngineBackwardCompatibility:**
- `test_existing_tests_pattern_still_works`: Create `SAEngine(SAParams(formula="C6H14", initial_temp=100, cooling_schedule_k=8, steps_per_cycle=100, num_cycles=2, optimization_mode="MINIMIZE", seed=42))` and run -- should succeed without specifying component_weights. Verify accounting sums to total_steps.
- `test_run_completes_with_multi_component`: Full run with `{"wiener_index": 0.5, "logp": 0.5}`, 100 steps x 2 cycles, seed=42. Verify: result has valid SMILES, accounting sums to total, acceptance_ratio in [0, 1].

Import from:
- `from pydantic import ValidationError`
- `from app.core.sa_engine import SAEngine`
- `from app.models.sa_params import SAParams`
- `import pytest`

Run tests: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_integration.py -x` -- tests should FAIL because SAParams doesn't have `component_weights` yet and SAEngine still uses hardcoded `compute_wiener_index`.
  </action>
  <verify>Run: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_integration.py -x 2>&1 | head -30` -- confirms test failures (not import errors, but assertion/validation failures since SAParams doesn't accept component_weights yet).</verify>
  <done>test_scoring_integration.py has 12+ tests, all failing because SAParams and SAEngine don't support multi-component scoring yet.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Extend SAParams and refactor SAEngine for multi-component scoring</name>
  <files>
    backend/app/models/sa_params.py
    backend/app/core/sa_engine.py
  </files>
  <action>
**1. Extend `backend/app/models/sa_params.py`:**

Add to SAParams class:

```python
from pydantic import BaseModel, Field, field_validator
from typing import Dict, Literal

# In SAParams class, add after the seed field:
component_weights: Dict[str, float] = Field(
    default_factory=lambda: {"wiener_index": 1.0},
    description="Weights for scoring components"
)

@field_validator("component_weights")
@classmethod
def validate_weights(cls, v: Dict[str, float]) -> Dict[str, float]:
    if not v:
        raise ValueError("At least one component weight must be specified")
    for name, weight in v.items():
        if weight < 0:
            raise ValueError(f"Component '{name}' has negative weight: {weight}")
    if all(w == 0.0 for w in v.values()):
        raise ValueError("At least one component weight must be non-zero")
    return v
```

Keep all existing fields unchanged. The `default_factory` ensures backward compatibility -- existing code that doesn't pass `component_weights` gets `{"wiener_index": 1.0}`.

**2. Refactor `backend/app/core/sa_engine.py`:**

Changes are minimal and surgical:

a) **Add import** at top:
```python
from app.core.scoring.registry import get_registry
```

b) **Remove import** of `compute_wiener_index`:
Delete `from app.core.wiener import compute_wiener_index`

c) **Add to `__init__()` after `self._rng = SeededRandom(params.seed)`:**
```python
# Load scoring component registry and validate requested components
registry = get_registry()
available = set(registry.list_components())
requested = set(params.component_weights.keys())
unknown = requested - available
if unknown:
    raise ValueError(
        f"Unknown scoring component(s): {unknown}. "
        f"Available: {sorted(available)}"
    )
self._component_weights = params.component_weights
self._registry = registry
```

d) **Add `_compute_energy()` method** (add before `_iterate()`):
```python
def _compute_energy(self, mol_graph: MoleculeGraph) -> float:
    """Compute weighted sum of scoring component contributions."""
    total_energy = 0.0
    for component_name, weight in self._component_weights.items():
        if weight == 0.0:
            continue
        component = self._registry.get(component_name)
        score = component.compute(mol_graph)
        total_energy += weight * score
    return total_energy
```

e) **Replace `compute_wiener_index` calls:**
- In `init()`: Change `self._current_energy = compute_wiener_index(self._current_graph)` to `self._current_energy = self._compute_energy(self._current_graph)`
- In `_iterate()`: Change `proposed_energy = compute_wiener_index(proposed_graph)` to `proposed_energy = self._compute_energy(proposed_graph)`

These are the ONLY two lines that change. Everything else (Metropolis criterion, optimization mode, history, etc.) remains untouched.

f) **Update module docstring** to mention multi-component scoring.

Run all tests:
```
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_scoring_integration.py tests/test_scoring_components.py tests/test_sa_engine.py tests/test_wiener.py -v
```

ALL tests must PASS. The existing SA engine tests in `test_sa_engine.py` use `SAParams` without `component_weights`, which defaults to `{"wiener_index": 1.0}` -- ensuring perfect backward compatibility.

Also run the full test suite to check for any regressions:
```
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest -v
```
  </action>
  <verify>
Run full test suite: `cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest -v` -- ALL tests pass including existing sa_engine, wiener, displacement, API, and streaming tests.

Specifically verify:
1. `test_scoring_integration.py` -- all 12+ new tests pass
2. `test_sa_engine.py` -- all 36 existing tests pass (backward compat)
3. `test_api_sa.py` -- API tests still work (SAParams serialization)
  </verify>
  <done>
SAEngine uses weighted sum of scoring components. Default `component_weights={"wiener_index": 1.0}` produces identical results to the old hardcoded engine. Multiple components with different weights produce correctly combined scores. Validation catches unknown components, negative weights, and all-zero weights. Full backward compatibility maintained -- all existing tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_scoring_integration.py -v` -- all 12+ integration tests pass
2. `python -m pytest tests/test_sa_engine.py -v` -- all 36 existing SA tests pass unchanged (backward compat)
3. `python -m pytest tests/test_wiener.py -v` -- existing Wiener tests still pass
4. `python -m pytest tests/test_api_sa.py -v` -- API configure endpoint works with default component_weights
5. `python -m pytest -v` -- full test suite passes with zero failures
6. SAEngine with `{"wiener_index": 2.0}` produces `initial_energy == 70` (35 * 2)
7. SAEngine with `{"wiener_index": 1.0, "logp": 1.0}` on C6H14 produces `initial_energy == 35 + LogP(linear hexane)`
</verification>

<success_criteria>
- SAParams has `component_weights: Dict[str, float]` field with default `{"wiener_index": 1.0}`
- SAParams validates: no negative weights, no all-zero weights, no empty weights dict
- SAEngine.__init__() validates component_weights against registry (fail-fast)
- SAEngine._compute_energy() returns weighted sum of component scores
- `compute_wiener_index` import removed from sa_engine.py
- All 36 existing SA engine tests pass without modification (backward compatibility)
- All 12+ new integration tests pass
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-component-target-function/07-02-SUMMARY.md`
</output>
