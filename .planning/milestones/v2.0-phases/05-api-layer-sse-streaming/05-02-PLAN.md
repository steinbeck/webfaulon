---
phase: 05-api-layer-sse-streaming
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/app/api/__init__.py
  - backend/app/api/sa_configure.py
  - backend/app/api/sa_control.py
  - backend/app/api/sa_status.py
  - backend/app/main.py
  - backend/tests/test_api_sa.py
autonomous: true

must_haves:
  truths:
    - "POST /api/sa/configure with valid SAParams returns session_id and status 'configured'"
    - "POST /api/sa/{session_id}/start transitions session to running state"
    - "POST /api/sa/{session_id}/pause transitions session to paused state"
    - "POST /api/sa/{session_id}/reset reinitializes session and sets state to idle"
    - "GET /api/sa/{session_id}/status returns current SA state snapshot for reconnection"
    - "All endpoints return 404 for nonexistent session IDs"
    - "Server health check still responds while session exists"
  artifacts:
    - path: "backend/app/api/sa_configure.py"
      provides: "POST /api/sa/configure endpoint"
      exports: ["router"]
    - path: "backend/app/api/sa_control.py"
      provides: "POST start/pause/reset endpoints"
      exports: ["router"]
    - path: "backend/app/api/sa_status.py"
      provides: "GET status endpoint"
      exports: ["router"]
    - path: "backend/app/main.py"
      provides: "Router registration and SessionManager singleton"
    - path: "backend/tests/test_api_sa.py"
      provides: "API endpoint test coverage"
  key_links:
    - from: "backend/app/api/sa_configure.py"
      to: "backend/app/services/session_manager.py"
      via: "session_manager.create(params)"
      pattern: "session_manager\\.create"
    - from: "backend/app/api/sa_control.py"
      to: "backend/app/services/session_manager.py"
      via: "session_manager.get(session_id)"
      pattern: "session_manager\\.get"
    - from: "backend/app/main.py"
      to: "backend/app/api/"
      via: "app.include_router()"
      pattern: "include_router"
---

<objective>
Implement REST API endpoints for SA session configuration, control, and status -- the command-and-query interface for the SA system.

Purpose: These endpoints let clients create SA sessions, control execution (start/pause/reset), and query state for reconnection. The SSE streaming endpoint (Plan 03) will use these same sessions.

Output: Three FastAPI routers (configure, control, status) registered in main.py, with comprehensive API tests.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-api-layer-sse-streaming/05-RESEARCH.md
@.planning/phases/05-api-layer-sse-streaming/05-01-SUMMARY.md
@backend/app/main.py
@backend/app/models/sa_params.py
@backend/app/models/errors.py
@backend/app/services/session_manager.py
@backend/app/services/svg_renderer.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure, Control, and Status API endpoints</name>
  <files>
    backend/app/api/__init__.py
    backend/app/api/sa_configure.py
    backend/app/api/sa_control.py
    backend/app/api/sa_status.py
  </files>
  <action>
**Create `backend/app/api/__init__.py`** (empty).

**Create `backend/app/api/sa_configure.py`:**

POST /api/sa/configure endpoint:
- Accepts SAParams as request body (Pydantic auto-validates)
- Calls session_manager.create(params) to create session
- Returns JSON: `{"session_id": "<uuid>", "status": "configured"}`
- Define a `ConfigureRequest` model that extends SAParams if needed, OR accept SAParams directly
- Define a `ConfigureResponse` Pydantic model: `session_id: str`, `status: str`
- Use `APIRouter(prefix="/api/sa", tags=["SA Configuration"])`
- The router should receive session_manager via dependency injection. Use a module-level variable that main.py sets, OR use FastAPI's `app.state`. Simplest: define a `get_session_manager()` function that returns a module-level singleton. Import from main module or create a dependencies.py file.

**Dependency injection pattern:** Create the SessionManager singleton in main.py (or a shared deps module). Each router imports it. Simplest approach: create `backend/app/dependencies.py` with:
```python
from app.services.session_manager import SessionManager
from app.config import Settings

settings = Settings()
session_manager = SessionManager(ttl_seconds=settings.session_ttl_seconds)
```
All API modules import `session_manager` from `app.dependencies`.

**Create `backend/app/api/sa_control.py`:**

Three POST endpoints under `/api/sa/{session_id}/`:
- `POST /start` -- transitions from idle/paused to running
  - Get session via session_manager.get(session_id)
  - If None: raise HTTPException(404, "Session not found or expired")
  - If session.state == "running": raise HTTPException(400, "Session already running")
  - If session.state == "complete": raise HTTPException(400, "Session already complete")
  - Set session.state = "running"
  - Return `{"status": "running", "session_id": session_id}`

- `POST /pause` -- transitions from running to paused
  - Get session, 404 if not found
  - If session.state != "running": raise HTTPException(400, "Session not running")
  - Set session.state = "paused"
  - Return `{"status": "paused", "session_id": session_id}`

- `POST /reset` -- reinitializes session to idle
  - Get session, 404 if not found
  - Call session.engine.init() to re-initialize
  - Set session.state = "idle"
  - Return `{"status": "idle", "session_id": session_id}`

Use `APIRouter(prefix="/api/sa", tags=["SA Control"])`.

**Create `backend/app/api/sa_status.py`:**

GET /api/sa/{session_id}/status endpoint:
- Get session via session_manager.get(session_id)
- If None: raise HTTPException(404, "Session not found or expired")
- Get engine state: `state = session.engine.get_state()`
- Generate SVG for best molecule: `svg = generate_molecule_svg(state.best_smiles)`
- Return JSON with session state + SVG:
  ```python
  {
      "session_id": session_id,
      "session_state": session.state,
      "step": state.step,
      "total_steps": state.total_steps,
      "cycle": state.cycle,
      "current_energy": state.current_energy,
      "best_energy": state.best_energy,
      "best_smiles": state.best_smiles,
      "best_svg": svg,
      "temperature": state.temperature,
      "accepted_moves": state.accepted_moves,
      "rejected_moves": state.rejected_moves,
      "invalid_moves": state.invalid_moves,
      "is_complete": state.is_complete
  }
  ```
- Define a `StatusResponse` Pydantic model for the response

Use `APIRouter(prefix="/api/sa", tags=["SA Status"])`.
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -c "
from app.api.sa_configure import router as configure_router
from app.api.sa_control import router as control_router
from app.api.sa_status import router as status_router
print('All routers importable')
print(f'Configure routes: {[r.path for r in configure_router.routes]}')
print(f'Control routes: {[r.path for r in control_router.routes]}')
print(f'Status routes: {[r.path for r in status_router.routes]}')
"
```
All three routers import without errors, routes are listed.
  </verify>
  <done>Three API routers created: sa_configure (POST /api/sa/configure), sa_control (POST start/pause/reset), sa_status (GET status). All use shared SessionManager from dependencies module. Pydantic response models defined for each.</done>
</task>

<task type="auto">
  <name>Task 2: Main.py wiring and API endpoint tests</name>
  <files>
    backend/app/main.py
    backend/app/dependencies.py
    backend/tests/test_api_sa.py
  </files>
  <action>
**Create `backend/app/dependencies.py`:**
```python
"""Shared dependencies for API endpoints."""
from app.services.session_manager import SessionManager
from app.config import Settings

settings = Settings()
session_manager = SessionManager(ttl_seconds=settings.session_ttl_seconds)
```

**Update `backend/app/main.py`:**
- Import all three routers: `from app.api.sa_configure import router as configure_router`, etc.
- Register routers AFTER exception handlers: `app.include_router(configure_router)`, etc.
- Add startup event for periodic TTL cleanup:
  ```python
  import asyncio
  from app.dependencies import session_manager

  @app.on_event("startup")
  async def startup_event():
      """Start periodic session cleanup."""
      async def periodic_cleanup():
          while True:
              await asyncio.sleep(300)  # Every 5 minutes
              session_manager.cleanup_expired()
      asyncio.create_task(periodic_cleanup())
  ```
- Keep ALL existing exception handlers and health check unchanged
- Do NOT remove or modify CORS middleware

**Create `backend/tests/test_api_sa.py`:**

Test using FastAPI TestClient (same pattern as existing tests):

1. **Configure endpoint tests:**
   - `test_configure_returns_session_id` -- POST /api/sa/configure with {"formula": "C6H14"} returns 200 with session_id (UUID format) and status "configured"
   - `test_configure_with_custom_params` -- POST with all params returns session_id
   - `test_configure_invalid_formula` -- POST with {"formula": ""} returns 422 validation error
   - `test_configure_invalid_params` -- POST with {"formula": "C6H14", "initial_temp": -1} returns 422

2. **Control endpoint tests:**
   - `test_start_session` -- create session, POST /api/sa/{id}/start returns 200 with status "running"
   - `test_start_already_running` -- start twice returns 400
   - `test_start_nonexistent_session` -- returns 404
   - `test_pause_running_session` -- create, start, POST /api/sa/{id}/pause returns 200 with status "paused"
   - `test_pause_not_running` -- pause idle session returns 400
   - `test_reset_session` -- create, start, POST /api/sa/{id}/reset returns 200 with status "idle"
   - `test_reset_nonexistent` -- returns 404

3. **Status endpoint tests:**
   - `test_status_returns_state` -- create session, GET /api/sa/{id}/status returns current state with all fields
   - `test_status_includes_svg` -- response contains "best_svg" field with "<svg" content
   - `test_status_nonexistent` -- returns 404
   - `test_status_after_start` -- status shows session_state as "running" after start

4. **Integration tests:**
   - `test_health_check_still_works` -- GET /health returns 200 (regression check)
   - `test_full_configure_start_pause_reset_flow` -- configure -> start -> pause -> reset flow works sequentially, each returning expected status

**Important:** Each test should use a fresh client/session. The test module needs to handle the shared `session_manager` from dependencies -- either override it in tests or use the same singleton. Since SessionManager is in-memory, tests will share state. Use `session_manager._sessions.clear()` in a fixture or create unique sessions per test.

Better approach: Create a pytest fixture that clears sessions between tests:
```python
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.dependencies import session_manager

@pytest.fixture(autouse=True)
def clear_sessions():
    """Clear all sessions between tests."""
    session_manager._sessions.clear()
    yield
    session_manager._sessions.clear()

@pytest.fixture
def client():
    return TestClient(app)
```
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_api_sa.py -v
```
All ~18 tests pass.

```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/ -v
```
Full suite passes with no regressions.

```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -c "
from fastapi.testclient import TestClient
from app.main import app
client = TestClient(app)
# Test configure
r = client.post('/api/sa/configure', json={'formula': 'C6H14'})
print(f'Configure: {r.status_code} {r.json()}'  )
sid = r.json()['session_id']
# Test status
r = client.get(f'/api/sa/{sid}/status')
print(f'Status: {r.status_code}, has svg: {\"<svg\" in r.json().get(\"best_svg\", \"\")}'  )
# Test start
r = client.post(f'/api/sa/{sid}/start')
print(f'Start: {r.status_code} {r.json()}'  )
# Test pause
r = client.post(f'/api/sa/{sid}/pause')
print(f'Pause: {r.status_code} {r.json()}'  )
# Test reset
r = client.post(f'/api/sa/{sid}/reset')
print(f'Reset: {r.status_code} {r.json()}'  )
# Health still works
r = client.get('/health')
print(f'Health: {r.status_code} {r.json()}'  )
"
```
Full flow works: configure -> status -> start -> pause -> reset -> health all return expected responses.
  </verify>
  <done>Main.py registers all three routers, startup event runs periodic TTL cleanup, dependencies.py provides shared SessionManager singleton. 18 API tests pass covering configure, control, status endpoints with error cases. Health check still works. Full test suite passes with no regressions.</done>
</task>

</tasks>

<verification>
1. `cd backend && python -m pytest tests/test_api_sa.py -v` -- all ~18 API tests pass
2. `cd backend && python -m pytest tests/ -v` -- full suite passes (no regressions)
3. Manual flow: configure -> start -> pause -> reset -> status all return expected responses
4. Health check at /health still responds correctly
5. OpenAPI docs at /docs show all new endpoints with correct schemas
</verification>

<success_criteria>
- POST /api/sa/configure creates session and returns session_id
- POST /api/sa/{id}/start|pause|reset control session state transitions
- GET /api/sa/{id}/status returns full state snapshot with SVG
- All endpoints return 404 for nonexistent sessions, 400 for invalid state transitions
- Health check unaffected by new endpoints
- Periodic TTL cleanup configured on startup
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-layer-sse-streaming/05-02-SUMMARY.md`
</output>
