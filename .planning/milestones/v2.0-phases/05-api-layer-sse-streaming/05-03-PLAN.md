---
phase: 05-api-layer-sse-streaming
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - backend/app/api/sa_stream.py
  - backend/app/main.py
  - backend/tests/test_api_stream.py
autonomous: true

must_haves:
  truths:
    - "GET /api/sa/{session_id}/stream returns SSE event stream with Content-Type text/event-stream"
    - "SSE progress events contain step, temperature, best_energy, best_smiles, best_svg, and is_complete fields"
    - "SSE stream respects pause state -- stops emitting progress events when paused, resumes when started"
    - "SSE stream sends completion event when SA optimization finishes"
    - "Server remains responsive to /health while SSE stream is active"
    - "Stream returns 404 for nonexistent session IDs"
    - "X-Accel-Buffering: no header present in SSE response for nginx compatibility"
  artifacts:
    - path: "backend/app/api/sa_stream.py"
      provides: "GET /api/sa/{session_id}/stream SSE endpoint"
      exports: ["router"]
    - path: "backend/tests/test_api_stream.py"
      provides: "SSE streaming test coverage"
  key_links:
    - from: "backend/app/api/sa_stream.py"
      to: "sse_starlette.sse"
      via: "EventSourceResponse import"
      pattern: "EventSourceResponse"
    - from: "backend/app/api/sa_stream.py"
      to: "backend/app/services/session_manager.py"
      via: "session_manager.get() for session retrieval"
      pattern: "session_manager\\.get"
    - from: "backend/app/api/sa_stream.py"
      to: "backend/app/services/svg_renderer.py"
      via: "generate_molecule_svg() for per-step SVG"
      pattern: "generate_molecule_svg"
    - from: "backend/app/api/sa_stream.py"
      to: "backend/app/core/sa_engine.py"
      via: "engine.step() and engine.get_state() in async generator"
      pattern: "engine\\.step\\(\\)|engine\\.get_state\\(\\)"
---

<objective>
Implement the SSE streaming endpoint -- the heart of real-time SA visualization. This endpoint runs SA steps inside an async generator, yielding progress events with molecule SVGs to the client.

Purpose: This is the key differentiator of the web app -- students watch the SA algorithm explore isomer space in real time. The SSE stream bridges the gap between backend computation and live frontend visualization.

Output: Working SSE endpoint that streams SA progress events, plus integration tests proving the full configure -> start -> stream flow works end-to-end.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-api-layer-sse-streaming/05-RESEARCH.md
@.planning/phases/05-api-layer-sse-streaming/05-01-SUMMARY.md
@.planning/phases/05-api-layer-sse-streaming/05-02-SUMMARY.md
@backend/app/main.py
@backend/app/api/sa_configure.py
@backend/app/api/sa_control.py
@backend/app/api/sa_status.py
@backend/app/services/session_manager.py
@backend/app/services/svg_renderer.py
@backend/app/dependencies.py
@backend/app/core/sa_engine.py
@backend/app/models/sa_params.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSE stream endpoint implementation</name>
  <files>
    backend/app/api/sa_stream.py
    backend/app/main.py
  </files>
  <action>
**Create `backend/app/api/sa_stream.py`:**

The SSE stream endpoint is the most complex part of the API. It runs SA steps INSIDE an async generator (per research: NOT in BackgroundTasks) and yields SSE events.

```python
from sse_starlette.sse import EventSourceResponse
from fastapi import APIRouter, Request, HTTPException
import asyncio
import json

from app.dependencies import session_manager
from app.services.svg_renderer import generate_molecule_svg

router = APIRouter(prefix="/api/sa", tags=["SA Streaming"])

@router.get("/{session_id}/stream")
async def stream_progress(session_id: str, request: Request):
    """Stream SA optimization progress via SSE.

    The SA engine runs steps inside the async generator. Each step yields
    a progress event. The generator respects pause/running state and
    checks for client disconnection.

    Events emitted:
    - "progress": step-by-step state updates (id = step number)
    - "complete": final result with best molecule SVG
    - "error": optimization error
    - "waiting": heartbeat when paused or idle (keeps connection alive)

    Headers:
    - X-Accel-Buffering: no (disables nginx buffering for real-time delivery)
    """
    session = session_manager.get(session_id)
    if not session:
        raise HTTPException(404, "Session not found or expired")

    async def event_generator():
        try:
            idle_count = 0
            while True:
                # Check client disconnect
                if await request.is_disconnected():
                    break

                # Session might have been deleted
                current_session = session_manager.get(session_id)
                if current_session is None:
                    break

                # Only step if running
                if current_session.state == "running":
                    idle_count = 0

                    # Check if engine is complete
                    if current_session.engine._completed:
                        # Send completion event
                        state = current_session.engine.get_state()
                        svg = generate_molecule_svg(state.best_smiles)
                        current_session.state = "complete"

                        yield {
                            "event": "complete",
                            "data": json.dumps({
                                "step": state.step,
                                "total_steps": state.total_steps,
                                "best_energy": state.best_energy,
                                "best_smiles": state.best_smiles,
                                "best_svg": svg,
                                "accepted_moves": state.accepted_moves,
                                "rejected_moves": state.rejected_moves,
                                "invalid_moves": state.invalid_moves,
                            })
                        }
                        break

                    # Execute one SA step
                    current_session.engine.step()
                    state = current_session.engine.get_state()

                    # Generate SVG for best molecule
                    svg = generate_molecule_svg(state.best_smiles)

                    yield {
                        "id": str(state.step),
                        "event": "progress",
                        "data": json.dumps({
                            "step": state.step,
                            "total_steps": state.total_steps,
                            "cycle": state.cycle,
                            "temperature": state.temperature,
                            "current_energy": state.current_energy,
                            "best_energy": state.best_energy,
                            "best_smiles": state.best_smiles,
                            "best_svg": svg,
                            "accepted_moves": state.accepted_moves,
                            "rejected_moves": state.rejected_moves,
                            "invalid_moves": state.invalid_moves,
                            "is_complete": state.is_complete,
                        })
                    }

                    # Check if just completed
                    if state.is_complete:
                        current_session.state = "complete"
                        yield {
                            "event": "complete",
                            "data": json.dumps({
                                "step": state.step,
                                "total_steps": state.total_steps,
                                "best_energy": state.best_energy,
                                "best_smiles": state.best_smiles,
                                "best_svg": svg,
                                "accepted_moves": state.accepted_moves,
                                "rejected_moves": state.rejected_moves,
                                "invalid_moves": state.invalid_moves,
                            })
                        }
                        break

                    # Yield control to event loop (~100 events/sec throttling)
                    await asyncio.sleep(0.01)

                elif current_session.state == "complete":
                    # Already complete, send final state and close
                    state = current_session.engine.get_state()
                    svg = generate_molecule_svg(state.best_smiles)
                    yield {
                        "event": "complete",
                        "data": json.dumps({
                            "step": state.step,
                            "total_steps": state.total_steps,
                            "best_energy": state.best_energy,
                            "best_smiles": state.best_smiles,
                            "best_svg": svg,
                        })
                    }
                    break

                else:
                    # Paused or idle -- send heartbeat to keep connection alive
                    idle_count += 1
                    if idle_count % 10 == 0:  # Every ~1 second
                        yield {
                            "event": "waiting",
                            "data": json.dumps({
                                "session_state": current_session.state,
                                "message": f"Session is {current_session.state}"
                            })
                        }
                    await asyncio.sleep(0.1)  # Check state 10x/sec when idle

        except Exception as e:
            yield {
                "event": "error",
                "data": json.dumps({"error": str(e)})
            }

    return EventSourceResponse(
        event_generator(),
        headers={"X-Accel-Buffering": "no"}
    )
```

**Key design decisions implemented:**
- SA steps run INSIDE the SSE generator (not BackgroundTasks)
- `await asyncio.sleep(0.01)` yields control between steps (~100 steps/sec)
- Checks `session.state` each iteration -- respects pause from control endpoint
- `await request.is_disconnected()` prevents generator leak on client disconnect
- "waiting" heartbeat events keep connection alive during pause/idle (every ~1s)
- X-Accel-Buffering: no header for nginx compatibility
- Error events catch and report exceptions

**Update `backend/app/main.py`:**
- Import stream router: `from app.api.sa_stream import router as stream_router`
- Register it: `app.include_router(stream_router)`
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -c "
from app.api.sa_stream import router
print(f'Stream routes: {[r.path for r in router.routes]}')
"
```
Stream router imports and has the /{session_id}/stream route.

```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -c "
from fastapi.testclient import TestClient
from app.main import app
client = TestClient(app)
# Verify all routes registered
routes = [r.path for r in app.routes]
print(f'Routes: {routes}')
assert '/api/sa/configure' in routes or any('configure' in r for r in routes)
print('All routes registered')
"
```
  </verify>
  <done>SSE stream endpoint implemented with async generator running SA steps, pause/running state checking, client disconnect detection, heartbeat events, and X-Accel-Buffering header. Router registered in main.py.</done>
</task>

<task type="auto">
  <name>Task 2: SSE streaming and end-to-end integration tests</name>
  <files>
    backend/tests/test_api_stream.py
  </files>
  <action>
**Create `backend/tests/test_api_stream.py`:**

Testing SSE with FastAPI's TestClient requires special handling. TestClient's `stream()` method works with httpx for streaming responses.

```python
import pytest
import json
from fastapi.testclient import TestClient
from app.main import app
from app.dependencies import session_manager

@pytest.fixture(autouse=True)
def clear_sessions():
    session_manager._sessions.clear()
    yield
    session_manager._sessions.clear()

@pytest.fixture
def client():
    return TestClient(app)
```

**Test cases:**

1. **SSE connection tests:**
   - `test_stream_nonexistent_session_returns_404` -- GET /api/sa/xxx/stream returns 404
   - `test_stream_returns_event_stream_content_type` -- Content-Type is text/event-stream
   - `test_stream_has_no_buffering_header` -- X-Accel-Buffering: no header present

2. **SSE event tests (using small SA run):**
   - `test_stream_emits_progress_events` -- Configure session with small params (formula="C4H10", steps_per_cycle=5, num_cycles=1), start it, connect to stream. Read events, verify "progress" events with step, temperature, best_energy fields.
   - `test_stream_emits_complete_event` -- Same small run, verify last event is "complete" with best_energy, best_smiles, best_svg fields
   - `test_progress_event_contains_svg` -- Verify progress event data includes "best_svg" field containing "<svg"
   - `test_progress_events_have_incrementing_steps` -- Step numbers increase through stream

3. **State interaction tests:**
   - `test_stream_idle_session_sends_waiting` -- Configure (don't start), connect to stream. First events should be "waiting" with session_state "idle". Use a brief connection with timeout to avoid hanging.

4. **End-to-end integration tests:**
   - `test_e2e_configure_start_stream_complete` -- Full flow: POST configure -> POST start -> GET stream -> receive progress events -> receive complete event. Verify accounting: total progress events roughly equal to steps_per_cycle * num_cycles.
   - `test_health_responsive_during_stream` -- Configure and start a session, verify /health still responds (use TestClient for health check).

**Testing SSE streams with httpx/TestClient:**
Use `client.stream("GET", url)` context manager to read the SSE response line by line. Parse SSE format (lines starting with "event:", "data:", "id:"):

```python
def parse_sse_events(response):
    """Parse SSE events from streaming response."""
    events = []
    current_event = {}
    for line in response.iter_lines():
        if line.startswith("event:"):
            current_event["event"] = line[len("event:"):].strip()
        elif line.startswith("data:"):
            current_event["data"] = json.loads(line[len("data:"):].strip())
        elif line.startswith("id:"):
            current_event["id"] = line[len("id:"):].strip()
        elif line == "":
            if current_event:
                events.append(current_event)
                current_event = {}
    if current_event:
        events.append(current_event)
    return events
```

For the streaming tests, use small SA runs (5 steps x 1 cycle = 5 total steps) to keep tests fast. The stream will auto-complete after all steps.

**Important:** The SSE stream runs SA steps synchronously (blocking in the generator). For TestClient, which runs in the same thread, the stream will block until complete. Use small step counts (5-10 total) to keep tests under 1 second.

**Alternative approach if TestClient streaming is problematic:** Use httpx AsyncClient with async test functions. The test can directly call the event generator and collect events. Since we're testing the logic, not the HTTP layer, this is acceptable.
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/test_api_stream.py -v
```
All ~10 SSE tests pass.

```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -m pytest tests/ -v
```
Full suite passes with no regressions (~190+ tests total).

**Manual end-to-end verification:**
```bash
cd /Users/steinbeck/Dropbox/develop/webfaulon/backend && python -c "
from fastapi.testclient import TestClient
from app.main import app
client = TestClient(app)

# Configure small session
r = client.post('/api/sa/configure', json={'formula': 'C4H10', 'steps_per_cycle': 5, 'num_cycles': 1, 'seed': 42})
sid = r.json()['session_id']
print(f'Session: {sid}')

# Start
r = client.post(f'/api/sa/{sid}/start')
print(f'Start: {r.json()}')

# Stream (will complete after 5 steps)
with client.stream('GET', f'/api/sa/{sid}/stream') as response:
    event_count = 0
    for line in response.iter_lines():
        if line.startswith('event:'):
            event_count += 1
            if 'complete' in line:
                print(f'Got complete event after {event_count} events')
                break
    print(f'Total events: {event_count}')

# Status after completion
r = client.get(f'/api/sa/{sid}/status')
print(f'Final status: session_state={r.json()[\"session_state\"]}, best_energy={r.json()[\"best_energy\"]}')
"
```
  </verify>
  <done>SSE streaming tests verify progress events with correct fields, completion events, SVG content, step incrementing, and full end-to-end flow. Health check remains responsive. All tests pass, full suite has no regressions.</done>
</task>

</tasks>

<verification>
1. `cd backend && python -m pytest tests/test_api_stream.py -v` -- all ~10 SSE tests pass
2. `cd backend && python -m pytest tests/ -v` -- full suite passes (~190+ tests, no regressions)
3. SSE stream returns Content-Type text/event-stream with X-Accel-Buffering: no header
4. Progress events contain step, temperature, best_energy, best_smiles, best_svg fields
5. Complete event sent when SA finishes with final results
6. /health still responds during active SSE stream
7. Full flow works: configure -> start -> stream -> complete
</verification>

<success_criteria>
- SSE endpoint streams real-time SA progress with step, temperature, energy, and molecule SVG
- Stream respects pause state (stops yielding progress events when paused)
- Stream sends completion event when SA optimization finishes
- X-Accel-Buffering: no header present for nginx compatibility
- Server remains responsive during active streams
- Full end-to-end flow (configure -> start -> stream -> complete) works
- All new tests pass, full suite has no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-layer-sse-streaming/05-03-SUMMARY.md`
</output>
