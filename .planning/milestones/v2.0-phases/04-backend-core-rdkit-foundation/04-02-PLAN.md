---
phase: 04-backend-core-rdkit-foundation
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/core/random.py
  - backend/app/core/formula_parser.py
  - backend/app/core/cooling.py
  - backend/tests/test_random.py
  - backend/tests/test_formula_parser.py
  - backend/tests/test_cooling.py
autonomous: true
must_haves:
  truths:
    - "SeededRandom with same seed produces identical sequences in Python and TypeScript"
    - "Formula parser correctly parses C6H14, C2H6O, CH4 to element-count dicts"
    - "Cooling schedule with k=8 reaches minimum temperature at 1/8 of total steps"
    - "HDI computation returns 0 for saturated alkanes and 4 for C6H6"
  artifacts:
    - path: "backend/app/core/random.py"
      provides: "Mulberry32 seeded PRNG matching TypeScript implementation"
      contains: "class SeededRandom"
    - path: "backend/app/core/formula_parser.py"
      provides: "Formula parsing and HDI computation"
      contains: "def parse_formula"
    - path: "backend/app/core/cooling.py"
      provides: "Faulon cooling schedule computation"
      contains: "def compute_temperature"
    - path: "backend/tests/test_random.py"
      provides: "Tests for SeededRandom determinism, range, selectNDistinct"
      min_lines: 50
    - path: "backend/tests/test_formula_parser.py"
      provides: "Tests for formula parsing and HDI"
      min_lines: 40
    - path: "backend/tests/test_cooling.py"
      provides: "Tests for cooling schedules k=0, k=1, k=8, k=32"
      min_lines: 30
  key_links:
    - from: "backend/app/core/random.py"
      to: "src/core/random.ts"
      via: "Same Mulberry32 algorithm"
      pattern: "0x6d2b79f5"
    - from: "backend/app/core/cooling.py"
      to: "src/core/cooling.ts"
      via: "Same Faulon cooling formula"
      pattern: "initial_temp.*schedule_k.*step.*total_steps"
---

<objective>
Port the three pure-Python utility modules (SeededRandom, formula parser, cooling schedule) from TypeScript to Python using TDD. These modules have no RDKit dependency and can be developed in parallel with Plan 01.

Purpose: These are foundational utilities used by displacement (random), initial structure generation (formula parser), and SAEngine (cooling). Porting them first with TDD ensures exact behavioral parity with TypeScript before tackling RDKit integration.
Output: Three tested Python modules matching TypeScript behavior, verified by ported test suites.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/core/random.ts
@src/core/__tests__/random.test.ts
@src/core/formulaParser.ts
@src/core/__tests__/formulaParser.test.ts
@src/core/cooling.ts
@src/core/__tests__/cooling.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port SeededRandom with TDD (RED-GREEN-REFACTOR)</name>
  <files>
    backend/app/core/random.py
    backend/tests/test_random.py
  </files>
  <action>
    NOTE: This plan runs in Wave 1 parallel with Plan 01. If `backend/pyproject.toml` does not exist yet (Plan 01 not finished), create a minimal one first:
    ```
    mkdir -p backend/app/core backend/tests
    cd backend && poetry init --name webfaulon-backend --python "^3.10" --no-interaction
    poetry add --group dev pytest
    poetry install
    ```
    If Plan 01 is already complete, skip this step and use its existing setup.

    **RED phase:** Create `backend/tests/test_random.py` ported from `src/core/__tests__/random.test.ts`:

    Port ALL test cases from TypeScript:
    - `test_same_seed_produces_same_first_value`: Two SeededRandom(42) instances produce identical first value
    - `test_identical_sequences_for_same_seed`: 1000 values from seed 12345 match
    - `test_different_sequences_for_different_seeds`: Seeds 111 vs 222, >90 of 100 values differ
    - `test_next_range_0_to_1`: 10000 values all in [0, 1)
    - `test_next_produces_different_values`: 3 consecutive calls are distinct
    - `test_next_int_range_inclusive`: 1000 calls of nextInt(0,5) all in [0,5]
    - `test_next_int_covers_range`: Over 1000 calls, all values 0-5 appear
    - `test_next_int_same_min_max`: nextInt(7,7) always returns 7
    - `test_next_int_negative_range`: nextInt(-10,-5) stays in range
    - `test_select_n_distinct_count`: selectNDistinct(4,10) returns exactly 4 unique values
    - `test_select_n_distinct_range`: Values in [0, range)
    - `test_select_n_distinct_n_equals_range`: selectNDistinct(10,10) returns all 0-9
    - `test_select_n_distinct_different_seeds`: Different seeds produce different selections
    - `test_select_n_distinct_same_seed`: Same seed produces same selection

    Run tests -- all should FAIL (no implementation yet).

    **GREEN phase:** Create `backend/app/core/random.py`:

    Port `SeededRandom` class from `src/core/random.ts`:
    - `__init__(self, seed: int)`: Initialize state with `seed | 0` (use `seed & 0xFFFFFFFF` in Python to simulate 32-bit)
    - `next(self) -> float`: Mulberry32 algorithm. CRITICAL: Python integers are arbitrary precision, so simulate 32-bit unsigned arithmetic:
      - Use `& 0xFFFFFFFF` after each operation to keep values in uint32 range
      - `Math.imul(a, b)` in JS = `((a * b) & 0xFFFFFFFF)` in Python, BUT must handle sign correctly. Use: `ctypes.c_int32(a).value * ctypes.c_int32(b).value` or bit-mask approach.
      - Actually simplest: use `numpy` or manual bit masking. The Mulberry32 in TypeScript:
        ```
        let t = (this.state += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        ```
      - In Python, implement with `ctypes.c_uint32` or manual masking to ensure identical output.
      - TEST: Verify `SeededRandom(42).next()` returns the EXACT same float as TypeScript `new SeededRandom(42).next()`.
    - `next_int(self, min_val: int, max_val: int) -> int`: Same as TS `nextInt`
    - `select_n_distinct(self, n: int, range_size: int) -> list[int]`: Same as TS `selectNDistinct`

    Run tests -- all should PASS.

    **REFACTOR:** Clean up if needed, ensure type hints are complete.
  </action>
  <verify>
    `cd backend && poetry run pytest tests/test_random.py -v` -- all tests pass.
    Verify cross-language determinism: run a quick comparison of first 10 values from seed 42 between Python and TypeScript (optional but recommended).
  </verify>
  <done>
    SeededRandom class produces identical sequences to TypeScript for same seeds. All test cases pass. next() returns [0,1), nextInt returns inclusive range, selectNDistinct returns correct unique values.
  </done>
</task>

<task type="auto">
  <name>Task 2: Port formula parser and cooling schedule with TDD</name>
  <files>
    backend/app/core/formula_parser.py
    backend/app/core/cooling.py
    backend/tests/test_formula_parser.py
    backend/tests/test_cooling.py
  </files>
  <action>
    **Formula Parser (RED-GREEN-REFACTOR):**

    RED: Create `backend/tests/test_formula_parser.py` ported from `src/core/__tests__/formulaParser.test.ts`:
    - `test_parse_simple_alkanes`: C6H14 -> {"C": 6, "H": 14}, CH4 -> {"C": 1, "H": 4}, C4H10 -> {"C": 4, "H": 10}
    - `test_parse_implicit_count_1`: CH4 -> {"C": 1, "H": 4}, CO2 -> {"C": 1, "O": 2}
    - `test_parse_heteroatoms`: C2H6O -> {"C": 2, "H": 6, "O": 1}, C6H5Cl -> {"C": 6, "H": 5, "Cl": 1}
    - `test_parse_multiple_heteroatoms`: C2H5NO2 -> {"C": 2, "H": 5, "N": 1, "O": 2}
    - `test_parse_empty_raises`: Empty string raises ValueError
    - `test_parse_unknown_element_raises`: "XYZ" raises ValueError with "Unknown element: X"
    - `test_parse_double_digit_counts`: C10H22 -> {"C": 10, "H": 22}
    - `test_parse_order_independence`: C6H14 and H14C6 produce same result
    - `test_hdi_saturated_alkanes`: C6H14->0, C4H10->0, CH4->0
    - `test_hdi_unsaturated`: C6H12->1, C6H6->4, C2H4->1, C2H2->2
    - `test_hdi_with_oxygen`: C2H6O->0, C2H4O->1
    - `test_hdi_with_nitrogen`: C2H7N->0, C2H5N->1
    - `test_hdi_with_halogens`: C6H5Cl->4, C2H5Br->0
    - `test_hdi_edge_cases`: CH4->0, H2->0

    GREEN: Create `backend/app/core/formula_parser.py`:
    - `KNOWN_ELEMENTS: set[str]` with same elements as TypeScript
    - `HALOGENS: set[str]` with F, Cl, Br, I
    - `parse_formula(formula: str) -> dict[str, int]`: Port from `src/core/formulaParser.ts`. Use `re.findall(r'([A-Z][a-z]?)(\d*)', formula)` pattern. Raise `ValueError` for empty formula or unknown elements.
    - `compute_hdi(formula: dict[str, int]) -> int`: Port HDI computation. Formula: (2C + 2 + N - H - halogens) / 2, clamped to min 0.

    **Cooling Schedule (RED-GREEN-REFACTOR):**

    RED: Create `backend/tests/test_cooling.py` ported from `src/core/__tests__/cooling.test.ts`:
    - `test_k0_constant_temperature`: k=0 returns 100 at steps 0, 500, 1000
    - `test_k1_initial_temperature`: k=1 at step 0 returns 100
    - `test_k1_final_temperature`: k=1 at step 1000 returns 0.01 (clamped)
    - `test_k1_halfway`: k=1 at step 500 returns 50
    - `test_k1_quarter`: k=1 at step 250 returns 75
    - `test_k8_initial`: k=8 at step 0 returns 100
    - `test_k8_reaches_min_early`: k=8 at step 125 returns 0.01
    - `test_k8_stays_at_min`: k=8 at steps 500, 1000 returns 0.01
    - `test_k32_reaches_min_very_early`: k=32 at step 32 returns 0.01
    - `test_clamps_to_minimum`: Never goes below 0.01
    - `test_different_initial_temperatures`: T0=200 with k=1
    - `test_total_steps_1`: Edge case totalSteps=1

    GREEN: Create `backend/app/core/cooling.py`:
    - `MIN_TEMPERATURE: float = 0.01`
    - `def compute_temperature(step: int, total_steps: int, initial_temp: float, schedule_k: int | float) -> float`:
      Port formula: `T = max(MIN_TEMPERATURE, initial_temp - schedule_k * initial_temp * step / total_steps)`

    REFACTOR: Ensure all type hints are complete.
  </action>
  <verify>
    ```
    cd backend && poetry run pytest tests/test_formula_parser.py tests/test_cooling.py -v
    ```
    All tests pass.
  </verify>
  <done>
    Formula parser correctly parses all formula patterns and computes HDI matching TypeScript values. Cooling schedule produces identical temperature values to TypeScript for all k values (0, 1, 8, 32). All test cases pass.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && poetry run pytest tests/test_random.py -v` -- all pass
2. `cd backend && poetry run pytest tests/test_formula_parser.py -v` -- all pass
3. `cd backend && poetry run pytest tests/test_cooling.py -v` -- all pass
4. SeededRandom(42) produces same sequence as TypeScript new SeededRandom(42)
5. parse_formula("C6H14") returns {"C": 6, "H": 14}
6. compute_hdi({"C": 6, "H": 6}) returns 4
7. compute_temperature(125, 1000, 100, 8) returns 0.01
</verification>

<success_criteria>
- All three Python modules are exact behavioral ports of TypeScript originals
- Test suites ported from TypeScript all pass
- SeededRandom determinism verified across languages
- Formula parser handles all element types including halogens and multi-digit counts
- Cooling schedule matches Faulon paper formulas for all k values
</success_criteria>

<output>
After completion, create `.planning/phases/04-backend-core-rdkit-foundation/04-02-SUMMARY.md`
</output>
