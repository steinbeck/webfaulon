---
phase: 04-backend-core-rdkit-foundation
plan: 04
type: tdd
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - backend/app/core/sa_engine.py
  - backend/app/models/sa_params.py
  - backend/tests/test_sa_engine.py
autonomous: true
must_haves:
  truths:
    - "Python SA engine runs 500 steps x 4 cycles on C6H14, producing valid SMILES at every step"
    - "Same seed produces identical results (bestEnergy, acceptedMoves, rejectedMoves)"
    - "MINIMIZE mode finds Wiener Index <= initial value (35 for linear hexane)"
    - "MAXIMIZE mode finds Wiener Index >= initial value"
    - "bestEnergy is monotonically non-increasing in MINIMIZE mode"
    - "accountingMoves: accepted + rejected + invalid == totalSteps"
    - "Step-by-step execution matches run() for same seed"
  artifacts:
    - path: "backend/app/core/sa_engine.py"
      provides: "Python SA engine with Metropolis criterion, step-by-step API"
      contains: "class SAEngine"
    - path: "backend/app/models/sa_params.py"
      provides: "Pydantic models for SA parameters and results"
      contains: "class SAParams"
    - path: "backend/tests/test_sa_engine.py"
      provides: "Comprehensive SA engine tests ported from TypeScript"
      min_lines: 120
  key_links:
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/displacement.py"
      via: "attempt_displacement for SA moves"
      pattern: "attempt_displacement"
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/wiener.py"
      via: "compute_wiener_index for energy evaluation"
      pattern: "compute_wiener_index"
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/cooling.py"
      via: "compute_temperature for cooling schedule"
      pattern: "compute_temperature"
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/initial_structure.py"
      via: "generate_initial_structure for starting molecule"
      pattern: "generate_initial_structure"
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/core/random.py"
      via: "SeededRandom for reproducible moves"
      pattern: "SeededRandom"
    - from: "backend/app/core/sa_engine.py"
      to: "backend/app/models/sa_params.py"
      via: "SAParams for configuration, SAStepResult/SAResult for output"
      pattern: "SAParams"
---

<objective>
Port the SAEngine from TypeScript to Python, integrating all previously ported modules (random, cooling, displacement, wiener, initial structure, molecule). This is the capstone plan that proves the entire Python backend core works end-to-end.

Purpose: The SA engine is the central algorithm. This plan validates that all ported modules compose correctly into a working optimizer that matches v1.0 behavior.
Output: A working Python SAEngine that runs complete SA optimizations on RDKit molecules, verified against the full TypeScript test suite.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-backend-core-rdkit-foundation/04-RESEARCH.md
@.planning/phases/04-backend-core-rdkit-foundation/04-02-SUMMARY.md
@.planning/phases/04-backend-core-rdkit-foundation/04-03-SUMMARY.md
@src/core/SAEngine.ts
@src/core/__tests__/SAEngine.test.ts
@src/core/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pydantic models for SA parameters and results</name>
  <files>
    backend/app/models/sa_params.py
  </files>
  <action>
    Create `backend/app/models/sa_params.py` with Pydantic v2 models:

    ```python
    from pydantic import BaseModel, Field
    from typing import Literal

    class SAParams(BaseModel):
        """Simulated annealing configuration parameters."""
        formula: str = Field(..., pattern=r"^([A-Z][a-z]?\d*)+$", examples=["C6H14"])
        initial_temp: float = Field(100.0, gt=0, description="Initial temperature kT_0")
        cooling_schedule_k: float = Field(8.0, ge=0, description="Cooling rate parameter k")
        steps_per_cycle: int = Field(500, gt=0, description="Steps per temperature cycle")
        num_cycles: int = Field(4, gt=0, description="Number of cooling cycles")
        optimization_mode: Literal["MINIMIZE", "MAXIMIZE"] = "MINIMIZE"
        seed: int = Field(42, description="Random seed for reproducibility")

    class SAStepResult(BaseModel):
        """Result of a single SA iteration."""
        step: int
        current_energy: float
        best_energy: float
        temperature: float
        accepted: bool

    class SAEngineState(BaseModel):
        """Snapshot of SA engine state for progress reporting."""
        step: int
        total_steps: int
        cycle: int
        current_energy: float
        best_energy: float
        best_smiles: str  # SMILES not MolBlock (memory per research pitfall #3)
        temperature: float
        accepted_moves: int
        rejected_moves: int
        invalid_moves: int
        is_complete: bool

    class SAResult(BaseModel):
        """Complete optimization result."""
        best_energy: float
        best_smiles: str
        final_energy: float
        final_smiles: str
        initial_energy: float
        total_steps: int
        accepted_moves: int
        rejected_moves: int
        invalid_moves: int
        acceptance_ratio: float
        history: list[SAStepResult]
    ```

    Key differences from TypeScript types:
    - `best_smiles` instead of `bestMolBlock` (store SMILES not Mol objects, per research pitfall #3)
    - `final_smiles` instead of `finalGraph` (same reason)
    - snake_case naming (Python convention)
    - Pydantic validation on SAParams (pattern, gt, ge constraints)
  </action>
  <verify>
    ```
    cd backend && poetry run python -c "
    from app.models.sa_params import SAParams
    p = SAParams(formula='C6H14')
    print(p.model_dump())
    # Test validation
    try:
        SAParams(formula='')
    except Exception as e:
        print(f'Validation works: {e}')
    "
    ```
  </verify>
  <done>
    Pydantic models created with validation constraints. SAParams validates formula pattern and numeric ranges. SAResult uses SMILES strings instead of Mol objects.
  </done>
</task>

<task type="auto">
  <name>Task 2: SAEngine implementation and comprehensive tests (TDD)</name>
  <files>
    backend/app/core/sa_engine.py
    backend/tests/test_sa_engine.py
  </files>
  <action>
    **RED phase:** Create `backend/tests/test_sa_engine.py` ported from `src/core/__tests__/SAEngine.test.ts`:

    Default params fixture:
    ```python
    DEFAULT_PARAMS = SAParams(
        formula="C6H14",
        initial_temp=100,
        cooling_schedule_k=8,
        steps_per_cycle=100,
        num_cycles=2,
        optimization_mode="MINIMIZE",
        seed=42,
    )
    ```

    **Basic functionality:**
    - `test_creates_with_valid_params`: Engine instantiates without error
    - `test_run_returns_all_fields`: run() returns SAResult with all required fields
    - `test_history_length`: history has totalSteps entries
    - `test_accounting_sums_to_total`: accepted + rejected + invalid == totalSteps
    - `test_acceptance_ratio_range`: 0 <= ratio <= 1

    **Determinism:**
    - `test_same_seed_identical_results`: Seed 42 twice produces same bestEnergy, acceptedMoves, rejectedMoves
    - `test_different_seeds_differ`: Seed 42 vs 123 produce different results

    **Minimization:**
    - `test_minimize_improves_c6h14`: bestEnergy <= initialEnergy (35 for linear hexane)
    - `test_minimize_initial_energy_35`: initialEnergy is 35 (linear hexane Wiener Index)
    - `test_minimize_best_le_final`: bestEnergy <= finalEnergy
    - `test_minimize_accepted_moves_positive`: acceptedMoves > 0

    **Maximization:**
    - `test_maximize_c6h14`: bestEnergy >= initialEnergy
    - `test_maximize_best_ge_final`: bestEnergy >= finalEnergy

    **Chemical validity:**
    - `test_best_smiles_valid`: best_smiles is non-empty and parseable by RDKit
    - `test_final_smiles_valid`: final_smiles is non-empty and parseable by RDKit

    **History tracking:**
    - `test_history_step_numbers`: Steps 1 through totalSteps
    - `test_history_best_non_increasing_minimize`: bestEnergy never increases
    - `test_history_best_non_decreasing_maximize`: bestEnergy never decreases

    **Metropolis criterion:**
    - `test_low_temp_accepts_some`: T=0.01 constant, some moves accepted
    - `test_high_temp_high_acceptance`: T=1000 constant, acceptance ratio > 0.3
    - `test_high_temp_higher_than_low_temp`: High temp acceptance > low temp acceptance
    - `test_very_high_temp_frequent_worsening`: T=1000 constant, ratio > 0.5

    **Edge cases:**
    - `test_small_molecule_c4h10`: Works on 4-carbon molecule
    - `test_single_cycle`: numCycles=1, stepsPerCycle=10, totalSteps=10
    - `test_many_cycles`: numCycles=10, stepsPerCycle=10, totalSteps=100

    **Step-by-step execution:**
    - `test_init_sets_initial_state`: step=0, isComplete=False, energy > 0
    - `test_step_advances`: step() increments step counter
    - `test_step_before_init_raises`: step() without init() raises
    - `test_multiple_steps`: 5 steps, state.step == 5
    - `test_is_complete_after_all_steps`: 10 steps, isComplete=True
    - `test_step_after_complete_raises`: Extra step() after completion raises
    - `test_get_result_after_complete`: getResult() works after completion
    - `test_get_result_before_complete_raises`: getResult() before completion raises
    - `test_step_matches_run`: Step-by-step with seed 12345 matches run() with seed 12345
    - `test_run_backward_compatible`: run() still works unchanged

    **Full SA run (integration):**
    - `test_full_run_500x4_c6h14`: Run 500 steps x 4 cycles on C6H14. Verify: bestEnergy <= 35, valid SMILES at every history entry, accepted + rejected + invalid = 2000.

    **GREEN phase:** Create `backend/app/core/sa_engine.py`:

    Port `SAEngine` class from `src/core/SAEngine.ts`:

    ```python
    class SAEngine:
        """Simulated Annealing Engine for molecular graph optimization."""

        def __init__(self, params: SAParams):
            self._params = params
            self._rng = SeededRandom(params.seed)
            # These are set in init()
            self._current_graph: MoleculeGraph | None = None
            self._current_energy: float = 0
            self._best_graph: MoleculeGraph | None = None
            self._best_energy: float = 0
            self._initial_energy: float = 0
            self._accepted_moves: int = 0
            self._rejected_moves: int = 0
            self._invalid_moves: int = 0
            self._history: list[SAStepResult] = []
            self._total_steps: int = 0
            self._global_step: int = 0
            self._current_temperature: float = 0
            self._initialized: bool = False
            self._completed: bool = False

        def init(self) -> None:
            """Initialize engine. Must be called before step()."""
            self._current_graph = generate_initial_structure(self._params.formula)
            self._current_energy = compute_wiener_index(self._current_graph)
            self._initial_energy = self._current_energy
            self._best_graph = self._current_graph.clone()
            self._best_energy = self._current_energy
            self._total_steps = self._params.steps_per_cycle * self._params.num_cycles
            self._global_step = 0
            self._accepted_moves = 0
            self._rejected_moves = 0
            self._invalid_moves = 0
            self._history = []
            self._current_temperature = self._params.initial_temp
            self._initialized = True
            self._completed = False

        def step(self) -> None:
            """Execute single SA iteration."""
            if not self._initialized:
                raise RuntimeError("step() called before init()")
            if self._completed:
                raise RuntimeError("step() called after completion")

            self._global_step += 1
            self._current_temperature = compute_temperature(
                self._global_step - 1,  # 0-indexed for temperature
                self._total_steps,
                self._params.initial_temp,
                self._params.cooling_schedule_k,
            )
            self._iterate(self._current_temperature, self._global_step)

            if self._global_step == self._total_steps:
                self._completed = True

        def get_state(self) -> SAEngineState:
            """Get current execution state snapshot."""
            # ... (port from TypeScript)

        def get_result(self) -> SAResult:
            """Get final result. Only valid after completion."""
            if not self._completed:
                raise RuntimeError("get_result() called before completion")
            return SAResult(
                best_energy=self._best_energy,
                best_smiles=self._best_graph.to_smiles(),
                final_energy=self._current_energy,
                final_smiles=self._current_graph.to_smiles(),
                initial_energy=self._initial_energy,
                total_steps=self._total_steps,
                accepted_moves=self._accepted_moves,
                rejected_moves=self._rejected_moves,
                invalid_moves=self._invalid_moves,
                acceptance_ratio=self._accepted_moves / self._total_steps,
                history=self._history,
            )

        def run(self) -> SAResult:
            """Run full optimization. Convenience method."""
            self.init()
            while not self._completed:
                self.step()
            return self.get_result()

        def _iterate(self, temperature: float, step_number: int) -> None:
            """Execute single SA iteration (private)."""
            proposed = attempt_displacement(self._current_graph, self._rng)
            if proposed is None:
                self._invalid_moves += 1
                self._record_step(step_number, temperature, False)
                return

            proposed_energy = compute_wiener_index(proposed)

            # Delta based on optimization mode
            if self._params.optimization_mode == "MINIMIZE":
                delta_e = proposed_energy - self._current_energy
            else:
                delta_e = self._current_energy - proposed_energy

            accepted = self._metropolis_accept(delta_e, temperature)

            if accepted:
                self._accepted_moves += 1
                self._current_graph = proposed
                self._current_energy = proposed_energy
                if self._is_better(self._current_energy, self._best_energy):
                    self._best_graph = self._current_graph.clone()
                    self._best_energy = self._current_energy
            else:
                self._rejected_moves += 1

            self._record_step(step_number, temperature, accepted)

        def _is_better(self, proposed: float, current_best: float) -> bool:
            if self._params.optimization_mode == "MINIMIZE":
                return proposed < current_best
            return proposed > current_best

        def _metropolis_accept(self, delta_e: float, temperature: float) -> bool:
            if delta_e <= 0:
                return True
            import math
            probability = math.exp(-delta_e / temperature)
            return self._rng.next() < probability

        def _record_step(self, step_number: int, temperature: float, accepted: bool) -> None:
            self._history.append(SAStepResult(
                step=step_number,
                current_energy=self._current_energy,
                best_energy=self._best_energy,
                temperature=temperature,
                accepted=accepted,
            ))
    ```

    Key differences from TypeScript:
    - Uses `MoleculeGraph.to_smiles()` instead of `MolGraph.toMolBlock()` for best/final molecules (per research: store SMILES, not Mol objects)
    - Uses Pydantic models for SAStepResult/SAResult
    - Python naming conventions (snake_case)
    - `math.exp` instead of `Math.exp`

    Run tests -- all should PASS.

    **REFACTOR:** Clean up, add docstrings, verify type hints complete.
  </action>
  <verify>
    ```
    cd backend && poetry run pytest tests/test_sa_engine.py -v
    ```
    All tests pass. Full 500x4 integration test completes successfully.

    Also run ALL tests to verify nothing is broken:
    ```
    cd backend && poetry run pytest tests/ -v
    ```
  </verify>
  <done>
    Python SAEngine runs complete SA optimizations with Metropolis criterion, configurable cooling schedules, and step-by-step API. 500x4 run on C6H14 produces valid SMILES at every step. Determinism verified (same seed = same result). All test cases match TypeScript behavior.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && poetry run pytest tests/ -v` -- ALL tests pass (full suite including all prior plans)
2. Full SA run: `poetry run python -c "from app.core.sa_engine import SAEngine; from app.models.sa_params import SAParams; e = SAEngine(SAParams(formula='C6H14', steps_per_cycle=500, num_cycles=4)); r = e.run(); print(f'Best: {r.best_energy}, Initial: {r.initial_energy}, SMILES: {r.best_smiles}')"` -- prints best energy <= 35 with valid SMILES
3. Determinism: Two runs with seed=42 produce identical bestEnergy, acceptedMoves, rejectedMoves
4. Accounting: accepted + rejected + invalid == 2000 (500 * 4)
5. History: All bestEnergy values are monotonically non-increasing (MINIMIZE mode)
</verification>

<success_criteria>
- Python SA engine runs a complete optimization (500 steps x 4 cycles) on C6H14
- Every step produces a valid molecule (verified by SanitizeMol in displacement)
- Best energy improves from or matches initial Wiener Index of 35
- Same seed produces identical results across runs
- Step-by-step execution matches run() for same seed
- All ported test cases from TypeScript SAEngine.test.ts pass
- Full test suite (all plans) passes: `poetry run pytest tests/ -v`
</success_criteria>

<output>
After completion, create `.planning/phases/04-backend-core-rdkit-foundation/04-04-SUMMARY.md`
</output>
