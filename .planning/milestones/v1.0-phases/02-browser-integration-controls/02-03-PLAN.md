---
phase: 02-browser-integration-controls
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - index.html
  - src/main.ts
  - src/ui/app.ts
  - src/ui/presets.ts
  - src/ui/validation.ts
  - package.json
autonomous: false

must_haves:
  truths:
    - "User can enter a molecular formula and see validation feedback (accept C6H14, reject C6H99)"
    - "User can select from preset example molecules without knowing chemistry"
    - "User can adjust SA parameters (initial kT, cooling schedule, steps, cycles)"
    - "User can start, pause, and reset SA execution at any time"
    - "Browser remains responsive during 10,000-step SA execution"
    - "RDKit.js WASM loads successfully and can process molecular data"
  artifacts:
    - path: "src/ui/app.ts"
      provides: "Alpine.js application component with SA controls and state"
      contains: "Alpine.data"
    - path: "src/ui/presets.ts"
      provides: "Curated preset molecules for quick start"
      exports: ["PRESET_MOLECULES"]
    - path: "src/ui/validation.ts"
      provides: "Two-stage formula validation (format + chemical)"
      exports: ["validateFormula"]
    - path: "index.html"
      provides: "Full UI with Alpine.js directives for controls"
      contains: "x-data"
  key_links:
    - from: "src/ui/app.ts start()"
      to: "src/worker/sa-worker.ts run()"
      via: "Comlink proxy call with progress callback"
      pattern: "saWorker.*run"
    - from: "src/ui/app.ts"
      to: "src/ui/validation.ts"
      via: "import validateFormula for formula input"
      pattern: "validateFormula"
    - from: "src/ui/app.ts"
      to: "src/ui/presets.ts"
      via: "import PRESET_MOLECULES for selector"
      pattern: "PRESET_MOLECULES"
    - from: "index.html"
      to: "src/ui/app.ts"
      via: "Alpine.data registration in main.ts"
      pattern: "x-data=\"app\""
---

<objective>
Build the complete browser UI with Alpine.js controls, formula validation, presets, and RDKit.js WASM integration.

Purpose: This is the user-facing layer that makes the SA algorithm interactive. Users need to enter formulas (or pick presets), configure parameters, and control execution -- all without knowing internal implementation details. RDKit.js WASM must load to prove Phase 3 rendering will work.

Output: Fully functional control panel with formula input/validation, preset selector, parameter controls, play/pause/reset buttons, and verified RDKit.js WASM loading.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-browser-integration-controls/02-RESEARCH.md
@.planning/phases/02-browser-integration-controls/02-02-SUMMARY.md
@src/core/formulaParser.ts
@src/core/types.ts
@src/worker/types.ts
@src/main.ts
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create formula validation, presets, and Alpine.js app component</name>
  <files>src/ui/validation.ts, src/ui/presets.ts, src/ui/app.ts</files>
  <action>
**Create src/ui/validation.ts** -- Two-stage formula validation:

```typescript
import { parseFormula, computeHDI } from '../core/formulaParser';

export interface ValidationResult {
  valid: boolean;
  error: string;
  formula: string;
}

/**
 * Two-stage validation:
 * 1. Regex format check (fast, catches obviously wrong input)
 * 2. parseFormula() chemical validity (catches impossible compositions)
 */
export function validateFormula(formula: string): ValidationResult {
  const trimmed = formula.trim();

  if (!trimmed) {
    return { valid: false, error: 'Please enter a molecular formula', formula: trimmed };
  }

  // Stage 1: Format check
  const formatRegex = /^([A-Z][a-z]?\d*)+$/;
  if (!formatRegex.test(trimmed)) {
    return { valid: false, error: 'Invalid format. Use format like C6H14 or C8H10.', formula: trimmed };
  }

  // Stage 2: Chemical validity
  try {
    const parsed = parseFormula(trimmed);

    // Must contain at least carbon
    if (!parsed.C || parsed.C < 1) {
      return { valid: false, error: 'Formula must contain at least one carbon atom.', formula: trimmed };
    }

    // Check HDI is non-negative (already handled by computeHDI clamping, but check raw value)
    const C = parsed.C || 0;
    const H = parsed.H || 0;
    const N = parsed.N || 0;
    let halogens = 0;
    for (const el of ['F', 'Cl', 'Br', 'I']) {
      halogens += parsed[el] || 0;
    }
    const rawHDI = (2 * C + 2 + N - H - halogens) / 2;
    if (rawHDI < 0) {
      return { valid: false, error: `Too many hydrogens for this formula (HDI = ${rawHDI}).`, formula: trimmed };
    }

    // Must have at least 4 heavy atoms for displacement to work
    // (need to pick x1, y1, x2, y2 -- 4 distinct atoms)
    const heavyAtoms = Object.entries(parsed).reduce(
      (sum, [el, count]) => el !== 'H' ? sum + count : sum, 0
    );
    if (heavyAtoms < 4) {
      return { valid: false, error: 'Need at least 4 heavy atoms for SA displacement (e.g., C4H10).', formula: trimmed };
    }

    return { valid: true, error: '', formula: trimmed };
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : 'Invalid formula';
    return { valid: false, error: msg, formula: trimmed };
  }
}
```

**Create src/ui/presets.ts** -- Curated preset molecules:

```typescript
export interface PresetMolecule {
  name: string;           // Display name
  formula: string;        // Molecular formula
  description: string;    // Brief chemistry context
}

/**
 * Curated preset molecules for users who don't know chemistry.
 * Selected to show different SA behaviors:
 * - Small saturated: fast convergence
 * - Medium saturated: moderate exploration
 * - Aromatic: interesting isomer space
 * - Larger: demonstrates computation time
 */
export const PRESET_MOLECULES: PresetMolecule[] = [
  {
    name: 'Hexane isomers',
    formula: 'C6H14',
    description: 'Saturated 6-carbon chain. 5 constitutional isomers.'
  },
  {
    name: 'Octane isomers',
    formula: 'C8H18',
    description: 'Saturated 8-carbon chain. 18 constitutional isomers.'
  },
  {
    name: 'Ethylbenzene / Xylenes',
    formula: 'C8H10',
    description: 'Aromatic 8-carbon compound. Includes ring structures.'
  },
  {
    name: 'Decane isomers',
    formula: 'C10H22',
    description: 'Larger saturated chain. 75 constitutional isomers. Longer SA runs.'
  },
  {
    name: 'Naphthalene isomers',
    formula: 'C10H8',
    description: 'Highly unsaturated. Fused ring systems possible.'
  },
];
```

**Create src/ui/app.ts** -- Main Alpine.js application component:

The component manages all UI state and worker interaction. Key state:
- `formula`: string (bound to input)
- `validation`: ValidationResult (updated on formula change)
- `selectedPreset`: number | null (preset index)
- `initialTemp`: number (default 100)
- `coolingScheduleK`: number (default 8)
- `stepsPerCycle`: number (default 500)
- `numCycles`: number (default 4)
- `optimizationMode`: 'MAXIMIZE' | 'MINIMIZE' (default 'MINIMIZE')
- `state`: 'idle' | 'running' | 'paused' | 'complete'
- `progress`: SAProgressData | null
- `result`: SAResult | null
- `rdkitReady`: boolean (RDKit WASM loaded)
- `rdkitError`: string (RDKit loading error)

Key methods:
- `selectPreset(index)`: Set formula from preset, clear validation error, set selectedPreset
- `validateInput()`: Call validateFormula(), update validation state
- `start()`: Validate formula, initialize worker, call run() with Comlink.proxy progress callback, update state to 'running'
- `pause()`: Call worker.pause(), set state to 'paused'
- `resume()`: Call worker.resume(), set state to 'running'
- `reset()`: Terminate worker, clear results, set state to 'idle'
- `onProgress(data)`: Update progress state (Alpine reactivity will update UI)

The component exports a function that returns the Alpine.js data object. Register it in main.ts via `Alpine.data('app', appComponent)`.

Computed properties (getters):
- `canStart`: state === 'idle' && validation.valid
- `canPause`: state === 'running'
- `canResume`: state === 'paused'
- `totalSteps`: stepsPerCycle * numCycles
- `progressPercent`: progress ? (progress.step / progress.totalSteps * 100) : 0

Use Comlink.proxy() to wrap the onProgress callback before passing to worker.run(). Import Comlink in this module.

Seed should be generated from Date.now() for each run (not user-configurable in UI -- that's a developer concern).
  </action>
  <verify>Run `npx tsc --noEmit` (zero errors). Verify all three files exist and export expected symbols.</verify>
  <done>Three UI modules created: validation (two-stage), presets (5 molecules), app component (full state machine with worker integration).</done>
</task>

<task type="auto">
  <name>Task 2: Build HTML UI with Alpine.js directives and wire everything together</name>
  <files>index.html, src/main.ts</files>
  <action>
**Update src/main.ts** to initialize Alpine.js and register the app component:

```typescript
import Alpine from 'alpinejs';
import * as Comlink from 'comlink';
import { appComponent } from './ui/app';
import type { ISAWorker } from './worker/types';

// Worker management (keep existing initWorker/terminateWorker but update exports)
// ... existing worker code ...

// Register Alpine.js components
Alpine.data('app', appComponent);

// Start Alpine
Alpine.start();
```

Remove the temporary smokeTest() function from Plan 02 -- the UI now serves as the interaction layer.

**Update index.html** with full Alpine.js UI:

The HTML should be clean, functional, and suitable for classroom projection. Use inline Tailwind-style utility classes if desired, but keep it simple -- Phase 3 handles polish. Structure:

```html
<div x-data="app" class="container">

  <!-- Formula Input Section -->
  <section>
    <h2>Molecular Formula</h2>

    <!-- Preset selector -->
    <div>
      <label>Quick Start:</label>
      <select x-model="selectedPreset" @change="selectPreset($event.target.value)">
        <option value="">-- Choose a molecule --</option>
        <template x-for="(preset, index) in presets" :key="index">
          <option :value="index" x-text="preset.name + ' (' + preset.formula + ')'"></option>
        </template>
      </select>
      <p x-show="selectedPreset !== null" x-text="presets[selectedPreset]?.description" class="hint"></p>
    </div>

    <!-- Manual formula input -->
    <div>
      <label>Or enter formula:</label>
      <input type="text"
        x-model="formula"
        @input.debounce.300ms="validateInput()"
        placeholder="e.g., C6H14"
        :class="{ 'input-error': !validation.valid && formula.length > 0 }"
        :disabled="state !== 'idle'"
      >
      <p x-show="!validation.valid && formula.length > 0"
         x-text="validation.error"
         class="error-text"></p>
      <p x-show="validation.valid" class="valid-text">Formula valid</p>
    </div>
  </section>

  <!-- SA Parameters Section -->
  <section>
    <h2>SA Parameters</h2>

    <div class="param-grid">
      <div>
        <label>Initial Temperature (kT):</label>
        <input type="number" x-model.number="initialTemp" min="1" max="1000" step="10" :disabled="state !== 'idle'">
      </div>

      <div>
        <label>Cooling Schedule (k):</label>
        <select x-model.number="coolingScheduleK" :disabled="state !== 'idle'">
          <option value="0">f0 - Constant temperature</option>
          <option value="1">f1 - Linear cooling</option>
          <option value="4">f4 - Moderate decay</option>
          <option value="8">f8 - Fast decay (recommended)</option>
          <option value="16">f16 - Very fast decay</option>
          <option value="32">f32 - Extreme decay</option>
        </select>
      </div>

      <div>
        <label>Steps per Cycle:</label>
        <input type="number" x-model.number="stepsPerCycle" min="10" max="5000" step="50" :disabled="state !== 'idle'">
      </div>

      <div>
        <label>Number of Cycles:</label>
        <input type="number" x-model.number="numCycles" min="1" max="20" step="1" :disabled="state !== 'idle'">
      </div>

      <div>
        <label>Optimization:</label>
        <select x-model="optimizationMode" :disabled="state !== 'idle'">
          <option value="MINIMIZE">Minimize Wiener Index</option>
          <option value="MAXIMIZE">Maximize Wiener Index</option>
        </select>
      </div>
    </div>

    <p class="hint">Total steps: <span x-text="totalSteps"></span></p>
  </section>

  <!-- Controls Section -->
  <section>
    <h2>Execution</h2>
    <div class="controls">
      <button @click="start()" :disabled="!canStart" class="btn-primary">Start</button>
      <button @click="pause()" :disabled="!canPause">Pause</button>
      <button @click="resume()" :disabled="!canResume">Resume</button>
      <button @click="reset()" :disabled="state === 'idle'">Reset</button>
    </div>

    <!-- Progress display -->
    <div x-show="progress">
      <div class="progress-bar">
        <div class="progress-fill" :style="`width: ${progressPercent}%`"></div>
      </div>
      <p>
        Step <span x-text="progress?.step || 0"></span> / <span x-text="progress?.totalSteps || 0"></span>
        | Current: <span x-text="progress?.currentEnergy || '-'"></span>
        | Best: <span x-text="progress?.bestEnergy || '-'"></span>
        | Temp: <span x-text="progress?.temperature?.toFixed(2) || '-'"></span>
      </p>
    </div>

    <!-- Results display -->
    <div x-show="state === 'complete' && result">
      <h3>Results</h3>
      <p>Best Wiener Index: <strong x-text="result?.bestEnergy"></strong></p>
      <p>Initial Wiener Index: <span x-text="result?.initialEnergy"></span></p>
      <p>Accepted: <span x-text="result?.acceptedMoves"></span>
         | Rejected: <span x-text="result?.rejectedMoves"></span>
         | Invalid: <span x-text="result?.invalidMoves"></span></p>
      <p>Acceptance Ratio: <span x-text="(result?.acceptanceRatio * 100)?.toFixed(1) + '%'"></span></p>
    </div>
  </section>

  <!-- RDKit Status -->
  <section>
    <p x-show="rdkitReady" class="valid-text">RDKit.js WASM loaded</p>
    <p x-show="rdkitError" x-text="'RDKit error: ' + rdkitError" class="error-text"></p>
    <p x-show="!rdkitReady && !rdkitError" class="hint">Loading RDKit.js WASM...</p>
  </section>

</div>
```

Add minimal CSS in a `<style>` block in index.html (not a separate file -- keeps it simple):
- Basic layout (max-width container, sections with margin)
- Input styling (borders, padding)
- Error/valid text colors (red/green)
- Progress bar (simple div with background)
- Button styling (primary action highlighted)
- Disabled state styling
- Clean typography suitable for classroom projection (16px base, good contrast)

Do NOT use Tailwind or any CSS framework -- just plain CSS. Keep it minimal. Phase 3 handles visual polish.
  </action>
  <verify>Run `npx vite build` (build succeeds). Start `npx vite` and open browser -- UI should render with all controls. Enter "C6H14", click Start, see progress update. Click Pause, see execution stop. Click Resume, see it continue. Click Reset. Try invalid formula "C6H99" and see error message. Select a preset and verify formula populates.</verify>
  <done>Complete UI with formula input, validation feedback, presets, parameter controls, play/pause/reset, progress display, and results display. All controls functional.</done>
</task>

<task type="auto">
  <name>Task 3: Install and verify RDKit.js WASM loading</name>
  <files>package.json, src/ui/app.ts, vite.config.ts</files>
  <action>
**Install RDKit.js:**
```bash
npm install @rdkit/rdkit
```

Note: @rdkit/rdkit includes the WASM binary. Vite needs to be configured to handle it.

**Update vite.config.ts** to handle WASM if needed. RDKit.js may need `optimizeDeps` configuration:
```typescript
// Add if RDKit WASM loading requires it:
optimizeDeps: {
  exclude: ['@rdkit/rdkit']  // Don't pre-bundle WASM
}
```

**Add RDKit initialization to the app component** (src/ui/app.ts):

In the component's `init()` lifecycle method (called by Alpine when component mounts):
```typescript
async init() {
  // Load RDKit.js WASM
  try {
    // @ts-ignore - RDKit module has non-standard exports
    const initRDKitModule = (await import('@rdkit/rdkit')).default;
    const RDKit = await initRDKitModule();
    this.rdkitReady = true;

    // Smoke test: create a molecule from SMILES
    const mol = RDKit.get_mol('CCCCCC'); // n-hexane
    if (mol) {
      console.log('RDKit smoke test passed: n-hexane loaded');
      mol.delete(); // Clean up WASM memory
    }

    // Store RDKit instance for later use (Phase 3 rendering)
    (window as any).__rdkit = RDKit;
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : 'Failed to load RDKit.js';
    this.rdkitError = msg;
    console.error('RDKit initialization failed:', e);
    // RDKit failure is non-blocking -- SA can still run without rendering
  }
}
```

The RDKit initialization is non-blocking: if it fails, the SA engine can still run and show numerical results. The rdkitReady/rdkitError flags let the UI show loading state.

**Verify RDKit works** by checking browser console for "RDKit smoke test passed" and the UI showing "RDKit.js WASM loaded".

If @rdkit/rdkit npm package has issues with Vite (known pain point), fall back to CDN loading:
```html
<!-- In index.html, before main.ts script -->
<script src="https://unpkg.com/@rdkit/rdkit/dist/RDKit_minimal.js"></script>
```
Then in the app init:
```typescript
const RDKit = await (window as any).initRDKitModule();
```

Document which approach was used in the summary.
  </action>
  <verify>Open browser dev console. Verify "RDKit smoke test passed" message. Verify UI shows "RDKit.js WASM loaded" (not error). Run `npx vite build` (build succeeds including RDKit assets).</verify>
  <done>RDKit.js WASM loads in browser. Smoke test creates molecule from SMILES. UI shows RDKit ready status. Non-blocking initialization (SA works even if RDKit fails).</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify complete Phase 2 functionality</name>
  <files>index.html</files>
  <action>
This is a human verification checkpoint. Start dev server with `npx vite` and verify the complete Phase 2 functionality in browser.

What was built: Complete browser-based SA control panel with formula input, validation, presets, parameter controls, play/pause/reset, Web Worker execution, and RDKit.js WASM loading.

**Test 1 - Formula Validation (INP-01, INP-02):**
1. Enter "C6H14" -- should show "Formula valid" in green
2. Enter "C6H99" -- should show error about too many hydrogens
3. Enter "XYZ" -- should show format error
4. Enter "" -- should show "Please enter a molecular formula"
5. Enter "CH4" -- should show error about needing 4+ heavy atoms

**Test 2 - Preset Molecules (INP-03):**
1. Select "Hexane isomers" from dropdown
2. Formula input should auto-fill with "C6H14"
3. Description should appear below dropdown
4. Try all 5 presets -- each should populate formula

**Test 3 - SA Parameters (CTRL-01 through CTRL-04):**
1. Verify default values: kT=100, k=8, steps=500, cycles=4
2. Change each parameter and verify it updates
3. Verify "Total steps" display updates (steps * cycles)
4. Verify parameters are disabled during execution

**Test 4 - Play/Pause/Reset (CTRL-05):**
1. Select C6H14, click Start -- execution begins, progress updates
2. Click Pause -- execution stops, progress frozen
3. Click Resume -- execution continues from where it paused
4. Wait for completion -- results displayed
5. Click Reset -- all cleared, back to idle state

**Test 5 - Browser Responsiveness (ALG-07):**
1. Select C10H22 (decane, larger molecule)
2. Set steps=2000, cycles=5 (10,000 total steps)
3. Click Start
4. While running, try scrolling the page, clicking inputs, selecting text
5. Browser should remain responsive (no freezing)

**Test 6 - RDKit.js WASM:**
1. Check browser console for "RDKit smoke test passed"
2. Verify "RDKit.js WASM loaded" message appears in UI
3. If loading fails, verify SA still works without RDKit
  </action>
  <verify>All 6 tests pass. UI is functional and responsive. Type "approved" if all tests pass, or describe specific issues.</verify>
  <done>Human has verified: formula validation, presets, SA parameters, play/pause/reset controls, browser responsiveness during long execution, and RDKit.js WASM loading all work correctly.</done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
npx vite build

# All existing tests still pass
npx vitest run

# TypeScript clean
npx tsc --noEmit

# Dev server starts
npx vite
```
</verification>

<success_criteria>
1. User can enter molecular formula and see validation feedback (accept C6H14, reject C6H99)
2. User can select from 5 preset example molecules
3. User can adjust SA parameters (kT, cooling schedule, steps, cycles) via UI controls
4. User can start, pause, resume, and reset SA execution
5. Browser remains responsive during 10,000-step SA execution
6. RDKit.js WASM loads and can process molecular data
7. All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-browser-integration-controls/02-03-SUMMARY.md`
</output>
