---
phase: 01-molecular-graph-sa-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - vitest.config.ts
  - src/core/types.ts
  - src/core/MolGraph.ts
  - src/core/wiener.ts
  - src/core/__tests__/MolGraph.test.ts
  - src/core/__tests__/wiener.test.ts
autonomous: true

must_haves:
  truths:
    - "MolGraph validates valences on construction (rejects carbon with 5 bonds)"
    - "MolGraph validates connectivity on construction (rejects disconnected fragments)"
    - "Wiener Index for n-pentane linear chain equals 20 (n(n^2-1)/6 where n=5)"
    - "Wiener Index computation completes in under 5ms for 50-atom molecule"
    - "MolGraph clone produces independent copy (modifying clone does not affect original)"
  artifacts:
    - path: "src/core/types.ts"
      provides: "Atom interface, element valence map, SA-related type definitions"
      exports: ["Atom", "STANDARD_VALENCE"]
    - path: "src/core/MolGraph.ts"
      provides: "Molecular graph with adjacency matrix, validation, connectivity"
      exports: ["MolGraph"]
      min_lines: 100
    - path: "src/core/wiener.ts"
      provides: "BFS-based Wiener Index calculation"
      exports: ["computeWienerIndex"]
      min_lines: 30
    - path: "src/core/__tests__/MolGraph.test.ts"
      provides: "MolGraph unit tests"
      contains: "describe.*MolGraph"
    - path: "src/core/__tests__/wiener.test.ts"
      provides: "Wiener Index tests with known values"
      contains: "describe.*Wiener"
  key_links:
    - from: "src/core/wiener.ts"
      to: "src/core/MolGraph.ts"
      via: "imports MolGraph, calls getBondMatrix and getAtomCount"
      pattern: "import.*MolGraph"
    - from: "src/core/MolGraph.ts"
      to: "src/core/types.ts"
      via: "imports Atom interface and STANDARD_VALENCE"
      pattern: "import.*types"
---

<objective>
Set up the TypeScript project with Vite and Vitest, then implement the core MolGraph data structure and BFS-based Wiener Index calculation with comprehensive tests.

Purpose: Everything in Phase 1 depends on the MolGraph class (displacement, initial structure, SA engine all operate on it). The Wiener Index is the cost function for SA optimization. Getting these right with tests first prevents cascading errors in later plans.
Output: Working project scaffold, MolGraph class with validation, Wiener Index with verified correctness against known values from Faulon paper.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-molecular-graph-sa-core/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TypeScript project with Vite and Vitest</name>
  <files>package.json, tsconfig.json, vitest.config.ts, src/core/types.ts</files>
  <action>
Initialize a new Vite project with TypeScript template (vanilla-ts, NOT React -- this is a library/algorithm project for now, UI comes in Phase 2-3):

```bash
npm create vite@latest . -- --template vanilla-ts
npm install -D vitest @vitest/ui
```

Configure vitest.config.ts with:
- Test environment: node (pure algorithmic code, no DOM needed)
- Include pattern: src/**/*.test.ts
- Coverage provider if desired (optional)

Create src/core/types.ts with foundational types:

```typescript
export interface Atom {
  element: string;      // 'C', 'N', 'O', 'S', 'P', 'F', 'Cl', 'Br', 'I'
  implicitH: number;    // Computed from valence - (sum of bond orders)
}

export const STANDARD_VALENCE: Record<string, number> = {
  'C': 4, 'N': 3, 'O': 2, 'S': 2, 'P': 3,
  'F': 1, 'Cl': 1, 'Br': 1, 'I': 1
};
```

Also add SA-related types that will be used across the codebase:

```typescript
export type OptimizationMode = 'MAXIMIZE' | 'MINIMIZE';

export interface SAStepResult {
  step: number;
  energy: number;        // Wiener Index value
  bestEnergy: number;
  temperature: number;
  accepted: boolean;
}
```

Update tsconfig.json to enable strict mode, target ES2020+, and set paths alias for `@/` -> `src/`.

Add scripts to package.json: "test": "vitest", "test:ui": "vitest --ui", "test:run": "vitest run".
  </action>
  <verify>Run `npm test -- --run` and confirm Vitest executes (0 tests found is OK at this point). Run `npx tsc --noEmit` and confirm no TypeScript errors.</verify>
  <done>Project builds with zero TS errors, Vitest runs successfully, types.ts exports Atom interface and STANDARD_VALENCE map.</done>
</task>

<task type="auto">
  <name>Task 2: Implement MolGraph class with adjacency matrix, valence validation, and connectivity check</name>
  <files>src/core/MolGraph.ts, src/core/__tests__/MolGraph.test.ts</files>
  <action>
Implement MolGraph class in src/core/MolGraph.ts. This is the central data structure for the entire application.

**MolGraph class must provide:**

1. **Constructor** accepting atoms array and bonds matrix (number[][]):
   - Validates that bonds matrix is square and matches atoms length
   - Does NOT auto-validate connectivity/valences in constructor (SA engine needs to create intermediate states). Provide explicit validate() method instead.
   - Computes and stores implicitH for each atom based on valence - bondOrderSum

2. **Getters:**
   - `getAtomCount(): number` -- number of heavy atoms
   - `getAtom(index: number): Atom` -- atom at index (readonly copy)
   - `getAtoms(): readonly Atom[]` -- all atoms
   - `getBondOrder(i: number, j: number): number` -- bond order between atoms i,j
   - `getBondMatrix(): readonly number[][]` -- full adjacency matrix (readonly)
   - `getBondOrderSum(atomIndex: number): number` -- sum of bond orders for atom

3. **Validation methods:**
   - `isConnected(): boolean` -- BFS from atom 0, check all atoms reachable. O(n+m).
   - `hasValidValences(): boolean` -- for each atom, bondOrderSum + implicitH == STANDARD_VALENCE[element]. Return false if any atom overvalent.
   - `validate(): { connected: boolean; validValences: boolean }` -- run both checks

4. **Mutation (for displacement):**
   - `setBond(i: number, j: number, order: number): void` -- set bond order (symmetric: sets both [i][j] and [j][i]). Updates implicitH for both atoms. Throws if order < 0 or > 3.

5. **Clone:**
   - `clone(): MolGraph` -- deep copy (new arrays, independent atoms)

6. **Factory methods for testing:**
   - `static createLinearAlkane(n: number): MolGraph` -- C_n chain with single bonds (C-C-C-...-C)
   - `static createCyclohexane(): MolGraph` -- 6-carbon ring
   - `static createBranched(pattern: 'isobutane' | 'neopentane'): MolGraph` -- branched test cases

**Important design decisions:**
- Bond matrix is mutable (SA needs setBond for displacement). Use clone() before mutation to preserve originals.
- implicitH is recomputed on setBond, not lazy. This catches valence errors immediately.
- Constructor does NOT throw on invalid molecules. Validation is explicit via isConnected() and hasValidValences(). This is because the displacement operation creates the graph first, then validates -- throwing in constructor would prevent testing invalid states.

**Write tests in src/core/__tests__/MolGraph.test.ts:**

Test groups:
- Construction: create from atoms/bonds, verify atom count, bond orders
- Linear alkane factory: n=1 (methane, 0 heavy bonds), n=2 (ethane), n=5 (pentane), n=10
- Cyclohexane factory: 6 atoms, each bonded to 2 neighbors, connected
- Branched factories: isobutane (central C bonded to 3 others), neopentane (central C bonded to 4)
- Connectivity: connected graphs return true, manually disconnect a bond and verify false
- Valence validation: valid alkanes return true, manually add extra bond to make carbon pentavalent and verify false
- implicitH: pentane carbons -- terminal C has implicitH=3, internal C has implicitH=2
- setBond: set a bond, verify getBondOrder reflects change, verify symmetric
- Clone independence: clone graph, modify clone's bond, verify original unchanged
  </action>
  <verify>Run `npm test -- --run src/core/__tests__/MolGraph.test.ts` -- all tests pass. Run `npx tsc --noEmit` -- no type errors.</verify>
  <done>MolGraph class creates linear alkanes (n=1..50), cyclohexane, and branched structures. isConnected() correctly identifies connected vs disconnected graphs. hasValidValences() rejects overvalent atoms. All factory methods produce valid molecules. 15+ tests passing.</done>
</task>

<task type="auto">
  <name>Task 3: Implement BFS-based Wiener Index with known-value tests</name>
  <files>src/core/wiener.ts, src/core/__tests__/wiener.test.ts</files>
  <action>
Implement BFS-based Wiener Index calculation in src/core/wiener.ts.

**Function signature:**
```typescript
export function computeWienerIndex(graph: MolGraph): number
```

**Algorithm (from research -- O(n^2) for sparse molecular graphs):**
1. For each atom i from 0 to n-1:
   - Run BFS from atom i to compute distances to all other atoms
   - For each atom j where j > i (avoid double-counting):
     - Add distance[j] to total sum
   - If any distance is Infinity, throw Error('Graph is disconnected')
2. Return total sum

**BFS implementation:**
- Use array-based queue (push to end, read from head index) for O(1) dequeue
- Bond order > 0 means atoms are connected (treat all bond orders as distance 1 -- Wiener Index counts topological distance, not bond-order-weighted distance)
- Initialize distances array with Infinity, set start node to 0

**Important:** The Wiener Index counts distances in the HEAVY ATOM graph only. Implicit hydrogens are NOT included in the graph and do NOT contribute to distances. This matches Faulon paper equation on p.735.

**Write tests in src/core/__tests__/wiener.test.ts:**

Known values from Faulon paper and graph theory:
- n-pentane (linear C5): Wiener = 20 (formula: n(n^2-1)/6 = 5*24/6 = 20)
- n-hexane (linear C6): Wiener = 35 (6*35/6 = 35)
- n-butane (linear C4): Wiener = 10 (4*15/6 = 10)
- n-propane (linear C3): Wiener = 4 (3*8/6 = 4)
- Ethane (linear C2): Wiener = 1
- Methane (C1): Wiener = 0 (single atom, no pairs)
- Cyclohexane: Wiener = 27 (can be computed: pairs at distance 1: 6, distance 2: 6, distance 3: 3; total = 6*1 + 6*2 + 3*3 = 27)
- Isobutane (star C4 -- central C bonded to 3 others): Wiener = 9 (3 pairs at dist 1 + 3 pairs at dist 2 = 3 + 6 = 9)
- Neopentane (star C5 -- central C bonded to 4 others): Wiener = 16 (4 pairs at dist 1 + 6 pairs at dist 2 = 4 + 12 = 16)

**Performance test:**
- Create linear alkane with n=50
- Time computeWienerIndex() using performance.now()
- Assert < 5ms (requirement from ROADMAP success criteria #4)

**Edge cases:**
- Single atom graph: Wiener = 0
- Disconnected graph: throws error
  </action>
  <verify>Run `npm test -- --run src/core/__tests__/wiener.test.ts` -- all tests pass including performance test under 5ms for 50-atom molecule. Run `npm test -- --run` for full suite -- all tests pass.</verify>
  <done>Wiener Index correctly computes known values for n-pentane (20), n-hexane (35), cyclohexane (27), isobutane (9), neopentane (16). Performance under 5ms for 50-atom molecules. Throws on disconnected graphs. 10+ tests passing.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- --run` passes all tests (25+ tests)
2. `npx tsc --noEmit` shows zero TypeScript errors
3. MolGraph factory methods produce valid molecules for all test cases
4. Wiener Index matches Faulon paper values for n-paraffins
5. Performance: Wiener Index < 5ms for 50-atom linear chain
</verification>

<success_criteria>
- Project scaffolded with Vite + TypeScript + Vitest
- MolGraph class with adjacency matrix, setBond, clone, connectivity check, valence validation
- Factory methods: createLinearAlkane(n), createCyclohexane(), createBranched()
- Wiener Index computed via BFS in O(n^2), verified against 9+ known values
- All tests passing, zero TS errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-molecular-graph-sa-core/01-01-SUMMARY.md`
</output>
