---
phase: 03-visualization-ux
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/MolGraph.ts
  - src/core/__tests__/MolGraph.test.ts
  - src/core/types.ts
  - src/core/SAEngine.ts
  - src/worker/types.ts
  - src/worker/sa-worker.ts
autonomous: true

must_haves:
  truths:
    - "MolGraph can produce a valid SMILES string for any connected molecular graph"
    - "Best molecule SMILES is available in progress callbacks during SA execution"
    - "SAEngineState includes bestSMILES field reflecting the current best structure"
  artifacts:
    - path: "src/core/MolGraph.ts"
      provides: "toSMILES() method for SMILES string generation"
      contains: "toSMILES"
    - path: "src/core/types.ts"
      provides: "bestSMILES field in SAEngineState"
      contains: "bestSMILES"
    - path: "src/worker/types.ts"
      provides: "bestSMILES field in SAProgressData"
      contains: "bestSMILES"
    - path: "src/worker/sa-worker.ts"
      provides: "Worker includes bestSMILES in progress reports"
      contains: "bestSMILES"
  key_links:
    - from: "src/core/SAEngine.ts"
      to: "src/core/MolGraph.ts"
      via: "bestGraph.toSMILES() call in getState()"
      pattern: "bestGraph.*toSMILES"
    - from: "src/worker/sa-worker.ts"
      to: "src/core/SAEngine.ts"
      via: "getState().bestSMILES passed to progress callback"
      pattern: "currentState\\.bestSMILES"
---

<objective>
Add SMILES string generation to MolGraph and propagate best molecule SMILES through SAEngine state and worker progress callbacks.

Purpose: RDKit.js needs a SMILES string to render 2D molecular structures. Currently MolGraph stores atoms and bonds as adjacency matrix but has no SMILES output. The worker progress data also lacks SMILES, so the main thread cannot render the best molecule during SA execution.

Output: MolGraph.toSMILES() method (TDD), SAEngineState.bestSMILES field, SAProgressData.bestSMILES field, worker passing SMILES in progress callbacks.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-browser-integration-controls/02-03-SUMMARY.md
@src/core/MolGraph.ts
@src/core/types.ts
@src/core/SAEngine.ts
@src/worker/types.ts
@src/worker/sa-worker.ts
@src/core/__tests__/MolGraph.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Add toSMILES() to MolGraph</name>
  <files>src/core/MolGraph.ts, src/core/__tests__/MolGraph.test.ts</files>
  <action>
Implement a `toSMILES(): string` method on MolGraph using DFS-based SMILES generation.

**RED phase - Write failing tests first in MolGraph.test.ts:**

Test cases for toSMILES():
1. `MolGraph.createLinearAlkane(1)` → "C" (methane)
2. `MolGraph.createLinearAlkane(2)` → "CC" (ethane)
3. `MolGraph.createLinearAlkane(6)` → "CCCCCC" (n-hexane)
4. `MolGraph.createBranched('isobutane')` → SMILES with branch notation, e.g., "C(C)(C)C" or equivalent
5. `MolGraph.createBranched('neopentane')` → SMILES with branch notation, e.g., "C(C)(C)(C)C" or equivalent
6. `MolGraph.createCyclohexane()` → SMILES with ring closure, e.g., "C1CCCCC1"
7. A manually constructed graph with a double bond (e.g., ethene: 2 carbons, bond order 2) → "C=C"
8. A manually constructed graph with a triple bond (e.g., ethyne: 2 carbons, bond order 3) → "C#C"
9. A graph with heteroatoms: e.g., methanol (C bonded to O, single bond) → verify SMILES contains both C and O
10. Round-trip validation: for linear alkanes (n=3..8), verify that RDKit can parse the generated SMILES (this test can be skipped if RDKit isn't available in test env — mark with `it.skip` if needed)

For validation: the exact SMILES string can vary (canonical vs non-canonical). Tests should verify:
- String is non-empty
- For simple cases, matches expected pattern
- For complex cases, verify atom count and bond structure are preserved (parse SMILES back and check)

**GREEN phase - Implement toSMILES() in MolGraph.ts:**

Algorithm (DFS-based SMILES generation):
1. Build adjacency list from bond matrix (only bonds with order > 0)
2. Track visited atoms
3. Start DFS from atom 0
4. For each atom: output element symbol (C, N, O, etc.) — for organic subset atoms (B, C, N, O, P, S, F, Cl, Br, I) use bare symbols, others use brackets [X]
5. For bond orders > 1: output "=" for double, "#" for triple before the next atom
6. For branches: wrap side chains in parentheses
7. For ring closures: detect back-edges during DFS, assign ring closure digits
8. Implicit hydrogens are NOT written in SMILES (standard behavior)

Important: This is NOT canonical SMILES — just valid SMILES that RDKit can parse. Canonicalization is RDKit's job.

**REFACTOR phase (if needed):** Extract DFS helper as private method.
  </action>
  <verify>
Run `npx vitest run src/core/__tests__/MolGraph.test.ts` — all new toSMILES tests pass.
Run `npx vitest run` — all 149+ existing tests still pass (no regressions).
  </verify>
  <done>MolGraph.toSMILES() produces valid SMILES strings for linear chains, branched molecules, cyclic molecules, and molecules with double/triple bonds. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add bestSMILES to SAEngine state and worker progress</name>
  <files>src/core/types.ts, src/core/SAEngine.ts, src/worker/types.ts, src/worker/sa-worker.ts</files>
  <action>
Propagate the best molecule's SMILES string from SAEngine through the worker to the main thread.

**1. Update SAEngineState in src/core/types.ts:**
Add `bestSMILES: string` field to the `SAEngineState` interface.

**2. Update SAEngine.getState() in src/core/SAEngine.ts:**
In the `getState()` method, add `bestSMILES: this.bestGraph.toSMILES()` to the returned object.

Performance note: toSMILES() is called every time getState() is called, but getState() is only called every `reportInterval` steps (default: 10), so this is at most ~200 calls for a 2000-step run. MolGraph.toSMILES() is a simple DFS — negligible cost compared to Wiener Index computation.

**3. Update SAProgressData in src/worker/types.ts:**
Add `bestSMILES: string` field to the `SAProgressData` interface.

**4. Update worker progress reporting in src/worker/sa-worker.ts:**
In the `run()` method, where `progressData` is constructed from `currentState`, add:
`bestSMILES: currentState.bestSMILES,`

**5. Verify no regressions:**
The existing app.ts progress callback destructures progress data with spread (`{ ...data }`), so adding a new field is backward-compatible. The UI currently doesn't use bestSMILES yet (that comes in plan 03), but it must be present in the data.
  </action>
  <verify>
Run `npx vitest run` — all existing tests pass.
Verify types compile: `npx tsc --noEmit` passes without errors.
  </verify>
  <done>SAEngineState has bestSMILES field. SAProgressData has bestSMILES field. Worker includes bestSMILES in every progress report. All existing tests pass. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (existing 149+ plus new toSMILES tests)
2. `npx tsc --noEmit` — no type errors
3. MolGraph.toSMILES() works for linear, branched, cyclic, and unsaturated molecules
4. SAProgressData includes bestSMILES field
</verification>

<success_criteria>
- MolGraph.toSMILES() generates valid SMILES for all molecule types in the test suite
- bestSMILES flows from SAEngine → Worker → progress callback without errors
- All existing tests pass (zero regressions)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualization-ux/03-01-SUMMARY.md`
</output>
